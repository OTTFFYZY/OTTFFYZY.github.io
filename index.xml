<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OTTFF&#39;s Blog</title>
    <link>https://ottffyzy.github.io/</link>
    <description>Recent content on OTTFF&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 02 Jan 2025 23:01:39 -0800</lastBuildDate><atom:link href="https://ottffyzy.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[CF] E. Water Taps - Educational Codeforces Round 40</title>
      <link>https://ottffyzy.github.io/sols/codeforces/954/e/</link>
      <pubDate>Thu, 02 Jan 2025 23:01:39 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/954/e/</guid>
      <description>https://codeforces.com/contest/954/problem/E 题目大意 给出 $N (\le 2 \times 10 ^ 5)$ 个水龙头的水量 $a_i (\le 10 ^ 6)$ 和温度 $t_i (\le 10 ^ 6)$，每个水龙头可以取 $0 \sim a_i$ 的实数单位水量，问可以混合出 $T (\le 10 ^ 6)$ 温度的水最多多少。 若每个龙头取 $c_i$ 单位水，则混合水的温度为 $\frac{\sum c_i t_i)}{\sum c_i}$ 简</description>
    </item>
    
    <item>
      <title>[数学] 判断数字能否被 x 整除</title>
      <link>https://ottffyzy.github.io/notes/math/div/</link>
      <pubDate>Mon, 30 Dec 2024 12:19:01 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/math/div/</guid>
      <description>关于 2, 5, 4, 25 这一类比较显然。对于 $x = 2, 5$ 只需数字最后 $1$ 位能被被 $x$ 整除即可。 对于 $x = 4, 25$ 只需数字最后 $2$ 位能被整除即可。 之所以我们可以进行截断，是因为 $10 \equiv 0 \ (\bmod 2\ )$, $10 \equiv 0 \ (\bmod 5\ )$ 而 $100 \equiv 0 \ (\bmod 4\ )$, $100 \equiv 0 \ (\bmod</description>
    </item>
    
    <item>
      <title>C. Light Switches - Codeforces Round 963 (Div. 2)</title>
      <link>https://ottffyzy.github.io/sols/codeforces/1993/c/</link>
      <pubDate>Mon, 05 Aug 2024 22:40:48 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/1993/c/</guid>
      <description>https://codeforces.com/contest/1993/problem/C 题目大意 给定 $n$ 盏灯和 $n$ 长数组 $a_i (1 \le a_i \le 10^9)$ 和 $k$，$1 \le k \le n \le 2 \cdot 10^5$。 起初 $n$ 盏灯都不亮。$i$ 位置的灯在 $a_i$ 时刻第一次点亮，之后每过 $k$ 单位时间点亮熄灭状态反转一次。问最早什么时刻，所有灯都亮</description>
    </item>
    
    <item>
      <title>D. Med-imize - Codeforces Round 963 (Div. 2)</title>
      <link>https://ottffyzy.github.io/sols/codeforces/1993/d/</link>
      <pubDate>Mon, 05 Aug 2024 22:40:40 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/1993/d/</guid>
      <description>https://codeforces.com/contest/1993/problem/D 题目大意 给出一个 $n \ (le 5 \cdot 10^5)$ 长的数组 $a$ 其中 $a_i \le 10^9$。给定一个 $k \ (\le 5 \cdot 10^5)$。 不断地从数组中删去一些长为 $k$ 的子数组（删除后把数组接起来），使得最后的数组长度 $\le k$。 问此时剩余元素的中位数</description>
    </item>
    
    <item>
      <title>E. Level Up - Educational Codeforces Round 168</title>
      <link>https://ottffyzy.github.io/sols/codeforces/1997/e/</link>
      <pubDate>Wed, 31 Jul 2024 21:09:09 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/1997/e/</guid>
      <description>https://codeforces.com/contest/1997/problem/E 题目大意 给定 $n\ (\le 2 \cdot 10^5)$ 长的数组和 $q\ (\le 2 \cdot 10^5)$ 个询问。数组中元素 $a_i\ (\le 2 \cdot 10^5)$。对于参数 $k$，我们依次在数组中标记 $k$ 个不超过 $1$ 的数，之后从最后标记的下标开始，再标记 $k$ 个不超过 $2$ 的数，以此类推。 每</description>
    </item>
    
    <item>
      <title>D. Maximize the Root - Educational Codeforces Round 168</title>
      <link>https://ottffyzy.github.io/sols/codeforces/1997/d/</link>
      <pubDate>Tue, 30 Jul 2024 23:14:15 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/1997/d/</guid>
      <description>https://codeforces.com/contest/1997/problem/D 题目大意 给以棵 $1$ 为根的有根树，节点数 $n \ (2 \le n \le 2 \times 10^5)$。每个节点上有权重 $a_i \ (1 \le a_i \le 10^9)$。每次操作可以选择给节点 $i$ 的权值 $+1$ 给其子树中所有其他节点权值 $-1$。任意时刻结点权值不能为</description>
    </item>
    
    <item>
      <title>G. Penacony - Codeforces Round 962 (Div. 3)</title>
      <link>https://ottffyzy.github.io/sols/codeforces/1996/g/</link>
      <pubDate>Tue, 30 Jul 2024 00:30:20 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/1996/g/</guid>
      <description>https://codeforces.com/contest/1996/problem/G 题目大意 给出 $n \le 2 \cdot 10^5$ 个点的一个简单环，给出 $m \le 2 \cdot 10^5$ 组点。要求选最少的边，使得 $m$ 组点之间，都可以通过选的边连通。给的每组点 $u &amp;lt; v$。 简要题解 一般环形问题先想直线问题，再想断开环。 直线问题非常好解决</description>
    </item>
    
    <item>
      <title>F. Bomb - Codeforces Round 962 (Div. 3)</title>
      <link>https://ottffyzy.github.io/sols/codeforces/1996/f/</link>
      <pubDate>Tue, 30 Jul 2024 00:30:18 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/1996/f/</guid>
      <description>https://codeforces.com/contest/1996/problem/F 题目大意 给定 $n \le 2 \cdot 10^5$ 的两个数组 $a$ 和 $b$。可以执行 $k \le 10^9$ 次操作，每次操作选择某个 $i$ 然后 $ans += a[i]$，之后 $a[i] = max(0, a[i] - b[i])$。问最大的 $ans$ 是多少。 简要题解 题目贪心的策略是显然的，只需要选当前最大</description>
    </item>
    
    <item>
      <title>E. Decode - Codeforces Round 962 (Div. 3)</title>
      <link>https://ottffyzy.github.io/sols/codeforces/1996/e/</link>
      <pubDate>Tue, 30 Jul 2024 00:19:04 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/1996/e/</guid>
      <description>https://codeforces.com/contest/1996/problem/E 题目大意 给出 $01$ 串 $S$，长度 $\le 2 \cdot 10^5$。求其所有子串的 $01$ 个数相同的子串的个数。 简要题解 题目求 $\sum_l \sum_r \sum_x \sum_y [cnt0(x, y) == cnt1(x, y)] ,\ (1 \le l \le x \le y \le r \le n)$。 如果只有所有子串 $S(x, y)$ 的个数，那将非常好求。遇到 $0$ 就 $</description>
    </item>
    
    <item>
      <title>D. Dense Subsequence - Intel Code Challenge Final Round</title>
      <link>https://ottffyzy.github.io/sols/codeforces/724/d/</link>
      <pubDate>Sun, 28 Jul 2024 23:42:01 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/724/d/</guid>
      <description>https://codeforces.com/problemset/problem/724/D 题目大意 给定一个字符串 $S$ 串长 $\le 10^5$ 给定 $m \le |S|$。选择一些下标，使得所有长度为 $m$ 的子串都至少包含一个备选的下标。找出一组符合规定的下标，使其字符任意重排之后字典序最小，输出这个最小字典序的串。 简要题</description>
    </item>
    
    <item>
      <title>C. Sonya and Problem Wihtout a Legend - Codeforces Round 371 (Div. 1)</title>
      <link>https://ottffyzy.github.io/sols/codeforces/713/c/</link>
      <pubDate>Sat, 27 Jul 2024 22:59:08 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/713/c/</guid>
      <description>https://codeforces.com/contest/713/problem/C 题目大意 给定 $n \le 3000$ 的数组 $a$。每次操作可以使数组中的某个位置的值 $+1$ 或 $-1$。 问最少得操作次数使得数组严格单调递增。 简要题解 重要的 trick： $a_i &amp;lt; a_{i + 1} \iff a_i + 1 \le a_{i + 1} \iff a_i + 1 - i \le a_{i + 1} - i \iff a_i</description>
    </item>
    
    <item>
      <title>B. Searching Rectangles - Codeforces Round 371 (Div. 1)</title>
      <link>https://ottffyzy.github.io/sols/codeforces/713/b/</link>
      <pubDate>Fri, 26 Jul 2024 23:40:44 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/713/b/</guid>
      <description>https://codeforces.com/contest/713/problem/B 题目大意 给定 $n \times n \ (n \le 2^16)$ 个方格区域，上面有两个未知的，不相交的，平行于坐标轴的矩形。 可以给出不超过 $200$ 次平行于坐标轴的矩形的询问（左上右下坐标），每次会给出完全包含在询问区域中的矩形个数。 最后需要回</description>
    </item>
    
    <item>
      <title>C. The Values You Can Make - Codeforces Round 360 (Div.1)</title>
      <link>https://ottffyzy.github.io/sols/codeforces/687/c/</link>
      <pubDate>Mon, 22 Jul 2024 22:18:26 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/687/c/</guid>
      <description>题目链接 题目大意 给定 $n \le 500$ 个值的集合（值分别为 $a_i \le 500$）和一个值 $k \le 500$。 保证某个子集的和为 $k$。问对于子集和为 $k$ 的所有子集，有多少种不同的子集和，并输出这些可能得子集和。 简要题解 最初的想法</description>
    </item>
    
    <item>
      <title>E. Wooden Game - Codeforces Round 959 sponsored by NEAR (Div. 1 &#43; Div. 2)</title>
      <link>https://ottffyzy.github.io/sols/codeforces/1994/e/</link>
      <pubDate>Sun, 21 Jul 2024 21:17:11 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/1994/e/</guid>
      <description>https://codeforces.com/problemset/problem/1994/E 题目大意 给 $k$ 棵有根树，每棵大小为 $n_i$，根为 $1$，形态以每个非根点的父亲 $f_i$ 的形式给出。 一种操作可以去掉任意的子树并把子树的节点树“或”到答案 $ans$ 上。 求最大的 $ans$。 简要题解 这样的题一般的是考</description>
    </item>
    
    <item>
      <title>[算法][图论] Vizing 定理</title>
      <link>https://ottffyzy.github.io/algos/gt/vizing/</link>
      <pubDate>Wed, 17 Aug 2022 22:27:03 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/algos/gt/vizing/</guid>
      <description>Vizing 定理 对于简单图 $G$: $$\chi&amp;#39;(G) \le \Delta (G) &amp;#43; 1$$ 其中 $\chi&#39;(G)$ 为图 $G$ 的边色数，即最少使用多少颜色可以为 $G$ 的边染色，使得相邻边彼此颜色不同。$\Delta (G)$ 是图的最大点度数。 二分图 Vizing 定理 特别的对于二分图我们有 $$\chi&amp;#39;(G) = \Delta (G) $$ 我们可以构</description>
    </item>
    
    <item>
      <title>《Learning Python》 笔记 第 4 章 介绍 Python 对象类型</title>
      <link>https://ottffyzy.github.io/notes/learningpython/c04/</link>
      <pubDate>Thu, 27 Jan 2022 00:57:41 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/learningpython/c04/</guid>
      <description>第 4 章 介绍 Python 对象类型 Python 知识结构 程序由模块构成 模块包含语句 语句包含表达式 表达式创建并处理对象 为什么要使用内置类型 容易编写，可扩展，往往效率高，是语言标准的一部分。 Python 核心数据类型 数字、字符串、列表、字典、</description>
    </item>
    
    <item>
      <title>[算法][DP] 高维前缀和 SOS DP</title>
      <link>https://ottffyzy.github.io/algos/dp/sosdp/</link>
      <pubDate>Sun, 23 Jan 2022 21:53:06 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/algos/dp/sosdp/</guid>
      <description>高维前缀和 SOS DP 子集和问题 其实这类算法更多的是解决子集和 （sum of subset） 问题，因此也叫 SOS DP。 $$ sum[i] = \sum_{j \subseteq i} a[j] $$ 即 $$ sum[i] = \sum_{j | i = i} a[j] $$ 这里我们有个非常显然的做法是可以枚举所有集合判断是否是当前所求</description>
    </item>
    
    <item>
      <title>[Vim] usr_11</title>
      <link>https://ottffyzy.github.io/notes/vimusermanual/c11/</link>
      <pubDate>Wed, 19 Jan 2022 21:13:07 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/vimusermanual/c11/</guid>
      <description>usr_11 从崩溃中恢复 11.1 基本恢复 一般来说如果硬盘没坏，崩溃了之后，文件的大部分内容可以恢复。 vim -r &amp;lt;FILENAME&amp;gt;这时 Vim 会读取 .swp 文件。为安全起见可以另存这个新文件。 可以用 vimdiff 比较新旧文件。 如果编辑</description>
    </item>
    
    <item>
      <title>《Learning Python》 笔记 第 3 章 你应如何运行程序</title>
      <link>https://ottffyzy.github.io/notes/learningpython/c03/</link>
      <pubDate>Wed, 19 Jan 2022 15:54:54 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/learningpython/c03/</guid>
      <description>第 3 章 你应如何运行程序 交互式命令行模式 开始一个交互式会话 &amp;gt; python Windows （cmd）上使用 &amp;lt;CTRL-Z&amp;gt; UNIX/PowerShell 上使用 &amp;lt;CTRL-D&amp;gt; 结束会话。 Python 3.3 中的新 Windows 选项：PATH 和 启动器 启动器用户可以输入 py 代替 python 并避免一些配置步骤。启动器可以更好的显式</description>
    </item>
    
    <item>
      <title>《Learning Python》 笔记 第 2 章 Python 如何运行程序</title>
      <link>https://ottffyzy.github.io/notes/learningpython/c02/</link>
      <pubDate>Mon, 17 Jan 2022 23:47:31 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/learningpython/c02/</guid>
      <description>《Learning Python》 笔记 第 2 章 Python 如何运行程序 Python 解释器简介 Python 是一门编程语言，同时是一个名为解释器的软件包。 解释器是让其他程序运行起来的程序，是代码与机器的计算机硬件之间的软件逻辑层。 Python 包安装</description>
    </item>
    
    <item>
      <title>[Vim] usr_09</title>
      <link>https://ottffyzy.github.io/notes/vimusermanual/c09/</link>
      <pubDate>Mon, 17 Jan 2022 22:14:37 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/vimusermanual/c09/</guid>
      <description>usr_09 使用 GUI 版本 09.1 GUI 版本的组件 gvim &amp;lt;FILENAME&amp;gt; vim -g &amp;lt;FILENAME&amp;gt; 标题栏文件名后可能会跟一个符号 - 文件不能被修改 + 已经被修改过 = 文件只读 =+ 只读但被修改过 没有标记则是一个普通的打开但没修改过的文件。 09.2 使用鼠标 使用鼠标可以移动光标和选</description>
    </item>
    
    <item>
      <title>[Vim] usr_08</title>
      <link>https://ottffyzy.github.io/notes/vimusermanual/c08/</link>
      <pubDate>Mon, 17 Jan 2022 18:42:42 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/vimusermanual/c08/</guid>
      <description>usr_08 分割窗口 08.1 分割窗口 增加一个水平的分割线 :split要在窗口间跳转可以使用 &amp;lt;CTRL-W&amp;gt;w或 &amp;lt;CTRL-W&amp;gt;&amp;lt;CTRL-W&amp;gt;关闭当前窗口 :close多数时候类似于</description>
    </item>
    
    <item>
      <title>《Learning Python》 笔记 第 1 章 问答环节</title>
      <link>https://ottffyzy.github.io/notes/learningpython/c01/</link>
      <pubDate>Mon, 17 Jan 2022 16:47:13 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/learningpython/c01/</guid>
      <description>《Learning Python》 笔记 第 1 章 问答环节 Python 是一门脚本语言吗 Python 是通用型编程语言，时常扮演脚本语言的角色。 Python 的缺点 比起完全编译并比较底层的语言，执行速度不够快。 使用 Python 可以做什么 系统编程、GUI、</description>
    </item>
    
    <item>
      <title>[Vim] usr_07</title>
      <link>https://ottffyzy.github.io/notes/vimusermanual/c07/</link>
      <pubDate>Mon, 17 Jan 2022 00:30:44 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/vimusermanual/c07/</guid>
      <description>usr_07 编辑多个文件 07.1 编辑另一个文件 :edit &amp;lt;FILENAME&amp;gt;需要先保存当前文件的修改，或者使用 :edit! &amp;lt;FILENAME&amp;gt;放弃当前文件修改并打开另一个文件。 想编辑其他文件又不保存当前文件则可</description>
    </item>
    
    <item>
      <title>[Vim] usr_06</title>
      <link>https://ottffyzy.github.io/notes/vimusermanual/c06/</link>
      <pubDate>Mon, 17 Jan 2022 00:09:44 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/vimusermanual/c06/</guid>
      <description>usr_06 使用语法高亮 06.1 功能激活 :syntax enable只在支持色彩的终端中生效，在 vimrc 中加入 if &amp;amp;t_Co &amp;gt; 1 syntax enableendif只在 Gui 版本生效则在 gvimrc 加入 syntax enable06.2 颜色显示不出来或者显示出错误的颜色怎么办？ 终端不支持彩色，这时 vim 会</description>
    </item>
    
    <item>
      <title>[Vim] usr_05</title>
      <link>https://ottffyzy.github.io/notes/vimusermanual/c05/</link>
      <pubDate>Sat, 15 Jan 2022 17:10:30 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/vimusermanual/c05/</guid>
      <description>usr_05 选项设置 05.1 vimrc 文件 可以使用如下命令打开 Vim 配置文件 :edit $MYVIMRC可以在开头放上 source $VIMRUNTIME/defaults.vim来导入默认配置。vimrc 文件可以包含任何冒号命令。 05.2 vimrc 示例解释 if has(&amp;#34;vms&amp;#34;) set</description>
    </item>
    
    <item>
      <title>[Vim] usr_04</title>
      <link>https://ottffyzy.github.io/notes/vimusermanual/c04/</link>
      <pubDate>Thu, 13 Jan 2022 23:52:19 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/vimusermanual/c04/</guid>
      <description>usr_04 作小改动 04.1 操作符与动作 Vim 只删除从当前位置到”动作“把光标移动到的位置的前一个位置。是否包括光标所在的字符取决于你使用的移动命令。包括当前字符在参考手册中称为 inclusive、否则成为 exclusi</description>
    </item>
    
    <item>
      <title>[Vim] usr_03</title>
      <link>https://ottffyzy.github.io/notes/vimusermanual/c03/</link>
      <pubDate>Tue, 11 Jan 2022 22:38:05 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/vimusermanual/c03/</guid>
      <description>usr_03 移动 03.1 词移动 移动到下一个词开头位置 w移动到上一个词开头 b移动到下一个 单词末尾 e移动到前一个 单词末尾 ge一个单词以非单词字符（. - ( 等）结尾，要改变那些是单词字符详见 iskeyword 复位 iskeyword :set iskeyword$如果</description>
    </item>
    
    <item>
      <title>[Vim] usr_02</title>
      <link>https://ottffyzy.github.io/notes/vimusermanual/c02/</link>
      <pubDate>Tue, 11 Jan 2022 00:23:08 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/vimusermanual/c02/</guid>
      <description>usr_02 Vim 初步 02.1 第一次运行 Vim &amp;gt;gvim file.txt &amp;gt;vim file.txt 02.2 插入文本 普通模式 -&amp;gt; 插入模式 Insert。 i插入模式 -&amp;gt; 普通模式 &amp;lt;ESC&amp;gt;显示当前模式 :set showmode02.3 光标移动 kh l j02.4 删除字符 删除光标处的字符 x删除整行 dd删除两行（与下行）</description>
    </item>
    
    <item>
      <title>[Vim] usr_01</title>
      <link>https://ottffyzy.github.io/notes/vimusermanual/c01/</link>
      <pubDate>Mon, 10 Jan 2022 21:03:05 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/vimusermanual/c01/</guid>
      <description>usr_01 检查是否是 vi 兼容模式 :set compatible?查找配置文件 :scriptnames运行 vim tutor &amp;gt;vimtutor vimtutor 笔记 移动 ^ k&amp;lt; h l &amp;gt; j v不保存退出 :q!&amp;lt;ENTER&amp;gt;保存退出 :wq&amp;lt;ENTER&amp;gt; 普通模式 删除光标位置的字符 x普通</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 16 章 模板与泛型编程</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c16/</link>
      <pubDate>Thu, 19 Aug 2021 22:26:25 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c16/</guid>
      <description>第 16 章 模板与泛型编程 本章内容随便记记，应该后续会跟进专门的书籍仔细学习。 16.1 定义模板 16.1.1 函数模板 函数模板 function template 模板参数 template parameter 模板参数列表 template parameter list 模板定义中，模板参数列表不能为空？ 使用模板时，我们隐式或显示的指定</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 14 章 重载运算与类型转换</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c14/</link>
      <pubDate>Sun, 01 Aug 2021 00:46:07 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c14/</guid>
      <description>第 14 章 重载运算与类型转换 14.1 基本概念 重载的运算符是具有特殊名字的函数。 重载运算符的参数数量与该运算符作用的运算对象数量一样多。除了重载的函数调用运算符 operator() 之外其他重载运算符不能含有默认实参。 一个重载运算符</description>
    </item>
    
    <item>
      <title>[模板][数据结构] 下标池 IdPool</title>
      <link>https://ottffyzy.github.io/tpls/ds/idpool/</link>
      <pubDate>Sat, 31 Jul 2021 19:22:06 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/ds/idpool/</guid>
      <description>下标池 IdPool template&amp;lt;typename T&amp;gt; struct IdPool { map&amp;lt;T, int&amp;gt; idmap; vector&amp;lt;T&amp;gt; items; void clear() { idmap.clear(); items.clear(); } int getid(const T &amp;amp;t) { auto it = idmap.find(t); if (it != idmap.end()) return it-&amp;gt;second; int ans = items.size(); items.push_back(t); idmap[t] = ans; return ans; } T&amp;amp; operator[](int i) { return items[i]; } int size() { return items.size(); } }; IdPool&amp;lt;int&amp;gt; idp;</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 13 章 拷贝控制</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c13/</link>
      <pubDate>Wed, 21 Jul 2021 22:57:24 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c13/</guid>
      <description>第 13 章 拷贝控制 拷贝控制 copy control 操作包括： 拷贝构造函数 copy constructor 拷贝赋值运算符 copy-assignment operator 移动构造函数 move constructor 移动赋值运算符 move-assignment operator 析构函数 destructor 13.1 拷贝、赋值与销毁 合成拷贝构造函数 synthesized copy constructor #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std; class A { public: string name; A() : name(&amp;#34;&amp;#34;) { cout &amp;lt;&amp;lt; &amp;#34;default ctor&amp;#34; &amp;lt;&amp;lt; endl; } A(string</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 12 章 动态内存</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c12/</link>
      <pubDate>Wed, 07 Jul 2021 00:59:01 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c12/</guid>
      <description>第 12 章 动态内存 静态内存用来存储 局部 static 对象，类 static 成员，定义在任何函数之外的变量。 栈内存用来存储 定义在函数内的非 static 对象。 除了这两部分，程序还拥有一个内存池。这部分内存被称为自由空间 free store 或 堆 heap。程序用</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 11 章 关联容器</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c11/</link>
      <pubDate>Mon, 05 Jul 2021 00:50:38 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c11/</guid>
      <description>第 11 章 关联容器 关联容器 associative-container map set multimap multiset unordered_map unordered_set unordered_multimap unordered_multiset 11.1 使用关联容器 map 通常称为关联数组 associative array。 11.2 关联容器概述 有序容器的关键字类型 需要定义 &amp;lt;，且该运算需要满足严格弱序 strict weak ordering。 11.2.3 pair 类型 pair 定义在</description>
    </item>
    
    <item>
      <title>[模板][计算几何] 平面最近点对</title>
      <link>https://ottffyzy.github.io/tpls/cg/nearestpair/</link>
      <pubDate>Sat, 03 Jul 2021 12:42:06 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/cg/nearestpair/</guid>
      <description>Title typedef long long LL; typedef vector&amp;lt;int&amp;gt; VI; typedef vector&amp;lt;VI&amp;gt; VVI; const LL INF=0x3f3f3f3f3f3f3f3f; inline LL sqr(LL x){ return x*x; } inline LL dis(const VI &amp;amp;a,const VI &amp;amp;b) { return sqr(a[0]-b[0])+sqr(a[1]-b[1]); } bool cmp(const VI &amp;amp;a, const VI &amp;amp;b) { return a[1]&amp;lt;b[1]; } VVI tmp; LL help(VVI &amp;amp;ps,int l,int r) { int n=r-l+1; if(n&amp;lt;=3) { LL ans=INF; for(int i=l;i&amp;lt;=r;i++) { for(int j=i+1;j&amp;lt;=r;j++) ans=min(ans,dis(ps[i],ps[j])); } sort(ps.begin()+l, ps.begin()+r+1, cmp); return ans; } int m=(l+r)&amp;gt;&amp;gt;1; int mp=ps[m][0]; LL ans=min(help(ps,l,m),help(ps,m+1,r)); int i=l,j=m+1,p=l; while(i&amp;lt;=m || j&amp;lt;=r) { if(i&amp;gt;m || j&amp;lt;=r&amp;amp;&amp;amp;cmp(ps[j],ps[i])) { tmp[p++]=ps[j++]; } else { tmp[p++]=ps[i++]; } } copy(tmp.begin()+l, tmp.begin()+r+1,ps.begin()+l); p=0; for(int i=l;i&amp;lt;=r;i++) { if(sqr(ps[i][0]-mp)</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 10 章 泛型算法</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c10/</link>
      <pubDate>Mon, 21 Jun 2021 20:52:05 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c10/</guid>
      <description>第 10 章 泛型算法 泛型算法 generic algorithm 10.1 概述 大多数算法定义在头文件 algorithm 中。另外在 numeric 种定义了一组数值泛型算法。 一般来说这些算法并不直接操作容器，二十遍历由两个迭代器指定的一个元素范围来进行操作。 10.2 初识泛型算法 10.2.1 只读算</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 9 章 顺序容器</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c9/</link>
      <pubDate>Thu, 17 Jun 2021 22:49:43 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c9/</guid>
      <description>第 9 章 顺序容器 sequential container 9.1 顺序容器概述 vector deque list forward_list array string 9.2 容器库概览 类型别名 意义 iterator 迭代器类型 const_iterator 不能修改元素的迭代器类型 size_type 容器类型最大可能的大小 difference_type 两个迭代器间的距离 value_type 元素类型 reference 元素的左值类型与 value_type&amp;amp; 相同 const_reference 元素的 const 左值类</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 8 章 IO 库</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c8/</link>
      <pubDate>Mon, 14 Jun 2021 20:22:01 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c8/</guid>
      <description>第 8 章 IO 库 8.1 IO 类 头文件 类型 作用 iostream istream, wistream 从流读 ostream, wostream 向流写 iostream,wiostream 读写流 fstream ifstream, wifstream 从文件读 ofstream, wofstream 向文件写 fstream, wfstream 读写文件 sstream istringstream, wistringstream 从 string 读 ostringstream, wostringstream 向 string 写 stringstream, wstringstream 读写 string ifstream 和 istringstream 继承自 istream ofstream 和 ostringstream 继承自 ostream IO 对象没有拷贝和赋值操作。 8.1.2 条件状态 IO 类定</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 7 章 类</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c7/</link>
      <pubDate>Tue, 01 Jun 2021 22:41:30 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c7/</guid>
      <description>第 7 章 类 类的基本思想是数据抽象 data abstraction 和封装 encapsulation。 数据抽象是一种依赖于接口 interface 和实现 implementation 分离的编程/设计技术。 7.1 定义抽象数据类型 引入 this this 是一个常量指针。 成员函数通过隐式参数 this 来访问调用它</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 6 章 函数</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c6/</link>
      <pubDate>Fri, 28 May 2021 11:50:51 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c6/</guid>
      <description>第 6 章 函数 6.1 函数基础 我们可以通过调用运算符 call operator 来执行函数。 形参 parameter 实参 argument 主调函数 calling function 被调函数 called function 空形参列表可以是空的括号，或是 void void f1() {} void f2(void) {} 6.1.1 局部对象 C++ 中名字有作用域，对象有声明周期 lifetime。 名</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 5 章 语句</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c5/</link>
      <pubDate>Thu, 27 May 2021 00:42:06 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c5/</guid>
      <description>第 5 章 语句 一个表达式末尾加上分号就变成了表达式语句 expression statement。 空语句 null statement。 复合语句 compound statement 也称块 block 是用花括号括起来的语句和声明序列。在程序某个位置如果语法上需要一个语句，逻辑上需</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 4 章 表达式</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c4/</link>
      <pubDate>Tue, 25 May 2021 22:00:23 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c4/</guid>
      <description>第 4 章 表达式 表达式 expression 由一个或多个运算对象 operand 组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，运算符 operator 将一个或多个对象组合起来可以生成复杂的表达式。 4.1 基础 4.1.1 基本概念 对于复杂的表达式，需要了</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 3 章 字符串、向量和数组</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c3/</link>
      <pubDate>Thu, 20 May 2021 23:32:08 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c3/</guid>
      <description>第 3 章 字符串、向量和数组 3.1 命名空间的 using 声明 using 声明 using declaration using namesapce::name; 头文件不应包含 using 声明。因为头文件会被包含到其他文件中去，使用 using 声明则可能带来名字冲突。 3.2 标准库类型 string 3.2.1 定义和初始化 string 对象 #include &amp;lt;iostream&amp;gt;#include &amp;lt;cassert&amp;gt;#include &amp;lt;iterator&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cctype&amp;gt; int main() { { // string::string()</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 2 章 变量和基本类型</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c2/</link>
      <pubDate>Mon, 17 May 2021 21:07:47 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c2/</guid>
      <description>第 2 章 变量和基本类型 2.1 基本内置类型 基本内置类型分为算数类型 arithmetic type 和空类型 void 2.1.1 算数类型 整型 integral type 和浮点型 注意 C++ 只规定了每种算数类型的最小尺寸，所以不同机器上可能会有差异。 类型 含义 最小尺寸 bool 未定义 char 8 位 wchar_t 宽字</description>
    </item>
    
    <item>
      <title>[模板] 随机数 Random</title>
      <link>https://ottffyzy.github.io/tpls/others/rnd/</link>
      <pubDate>Sun, 25 Apr 2021 18:19:08 -0700</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/others/rnd/</guid>
      <description>随机数 Random #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; typedef long long LL; struct FastIO { FastIO() { ios::sync_with_stdio(false); cin.tie(nullptr); } }fastio; mt19937 rnd(chrono::system_clock::now().time_since_epoch().count()); mt19937_64 rnd_64(chrono::system_clock::now().time_since_epoch().count()); // [0,r) int rndi(int r) { return rnd()%r; } // [l,r] r-l+1&amp;lt;=INT_MAX int rndi(int l,int r) { return rnd()%(r-l+1)+l; } LL rndll(LL l,LL r) { return rnd_64()%(r-l+1)+l; } char rndc() { return rndi(-128,127); } char rndc(const string &amp;amp;s) { return s[rndi(s.length())]; } char rnd_lower() { return rndi(26)+&amp;#39;a&amp;#39;; } char rnd_upper() { return rndi(26)+&amp;#39;A&amp;#39;; } char rnd_digit() { return rndi(10)+&amp;#39;0&amp;#39;; } char rnd_alpha() { int r=rndi(52); return r&amp;lt;26?(r+&amp;#39;a&amp;#39;):(r-26+&amp;#39;A&amp;#39;); } char rnd_alphadigit() { int r=rndi(62); if(r&amp;lt;10) return</description>
    </item>
    
    <item>
      <title>[模板][数据结构] 离散化 Discretization</title>
      <link>https://ottffyzy.github.io/tpls/ds/discretization/</link>
      <pubDate>Wed, 20 Jan 2021 11:39:32 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/ds/discretization/</guid>
      <description>离散化 Discretization template&amp;lt;typename T, int IdFrom=0, typename OpLs=less&amp;lt;T&amp;gt;, typename OpEq=equal_to&amp;lt;T&amp;gt;&amp;gt; struct Dctz { static OpLs ls; static OpEq eq; vector&amp;lt;T&amp;gt; x; void clear() { x.clear(); } void add(T v) { x.push_back(v); } void init() { sort(x.begin(),x.end(),ls); x.erase(unique(x.begin(),x.end(),eq),x.end()); } int size() { return x.size(); } int id(const T &amp;amp;v) { return lower_bound(x.begin(),x.end(),v,ls)-x.begin()+IdFrom; } T&amp;amp; operator[](int id) { return x[id-IdFrom]; }; }; Dctz&amp;lt;&amp;gt; dc;</description>
    </item>
    
    <item>
      <title>[算法][图论] 约翰逊 Johnson 算法 全源最短路</title>
      <link>https://ottffyzy.github.io/algos/gt/johnson/</link>
      <pubDate>Wed, 18 Nov 2020 13:33:50 -0500</pubDate>
      
      <guid>https://ottffyzy.github.io/algos/gt/johnson/</guid>
      <description>约翰逊 Johnson 算法 全源最短路 对于最短路问题，我们的常用算法是 Dijkstra 算法或 Bellman-Ford 算法。但这两个算法经常解决的是单源最短路问题。 对于多源（全源）最短路问题，我们有一个基于动态规划的优秀算法，Floyd-Warshall</description>
    </item>
    
    <item>
      <title>[模板][数论] 扩展欧几里得算法（ExGCD）</title>
      <link>https://ottffyzy.github.io/tpls/nt/exgcd/</link>
      <pubDate>Sun, 01 Nov 2020 22:38:49 -0500</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/nt/exgcd/</guid>
      <description>扩展欧几里得算法（ExGCD） // ax+by=gcd(a,b)=g // check a&amp;gt;0 b&amp;gt;0 // if a != b, |x|&amp;lt;b, |y|&amp;lt;a template&amp;lt;typename T&amp;gt; void exgcd(T a,T b,T &amp;amp;g,T &amp;amp;x,T &amp;amp;y) { if(!b) { g=a; x=1; y=0; } else { exgcd(b,a%b,g,y,x); y-=a/b*x; } } 求逆元 template&amp;lt;typename T&amp;gt; void exgcd(T a,T b,T &amp;amp;g,T &amp;amp;x,T &amp;amp;y) { if(!b) { g=a; x=1; y=0; } else { exgcd(b,a%b,g,y,x); y-=a/b*x; } } template&amp;lt;typename T&amp;gt; T inv(T a,T m) { T g,x,y; exgcd(a,m,g,x,y); if(g!=1) return -1; // no inverse element if(x&amp;lt;0) x+=m; return x; } 不定方</description>
    </item>
    
    <item>
      <title>[算法][数论] 扩展欧几里得算法</title>
      <link>https://ottffyzy.github.io/algos/nt/exgcd/</link>
      <pubDate>Sun, 01 Nov 2020 10:02:34 -0500</pubDate>
      
      <guid>https://ottffyzy.github.io/algos/nt/exgcd/</guid>
      <description>扩展欧几里得算法 有时我们需要求解类似于 $ax+by=m$ 的不定方程（丢番图方程），扩展欧几里得算法就是求解这样方程的利器。 除此以外我们可以通过简单地变形处理模逆元和线性同余方程。 裴蜀定理/贝祖定理（Bezout&amp;rs</description>
    </item>
    
    <item>
      <title>[算法][数论] 最大公约数（GCD）与欧几里得算法</title>
      <link>https://ottffyzy.github.io/algos/nt/gcd/</link>
      <pubDate>Sat, 31 Oct 2020 00:53:37 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/algos/nt/gcd/</guid>
      <description>最大公约数（GCD）与欧几里得算法 最大公约数（Greatest Common Divisor，GCD） 两个数最大公约数顾名思义，两个数的所有公约数中最大的。 若正整数 $a,b$ 的质因数分解为 $$a = \prod_{i} p_i ^ {e_{a,i}}$$ $$b = \prod_{i} p_i ^ {e_{b,i}}$$ 则其最大公</description>
    </item>
    
    <item>
      <title>[模板] 对拍程序</title>
      <link>https://ottffyzy.github.io/tpls/others/checker/</link>
      <pubDate>Tue, 20 Oct 2020 00:10:35 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/others/checker/</guid>
      <description>对拍程序 from os import system tc=0 while True: system(&amp;#34;python data.py &amp;gt; data.in&amp;#34;) system(&amp;#34;std.exe &amp;lt; data.in &amp;gt; std.out&amp;#34;) system(&amp;#34;my.exe &amp;lt; data.in &amp;gt; my.out&amp;#34;) # system(&amp;#34;diff std.out my.out &amp;gt; diff.out&amp;#34;): if system(&amp;#34;fc std.out my.out &amp;gt; diff.out&amp;#34;): print(&amp;#34;WA&amp;#34;) break else: tc += 1 print(&amp;#34;AC #%d&amp;#34;%tc) print(&amp;#34;-------------------- data.in --------------------&amp;#34;) # system(&amp;#34;cat data.in&amp;#34;) system(&amp;#34;type data.in&amp;#34;) print(&amp;#34;-------------------- std.out --------------------&amp;#34;) system(&amp;#34;type std.out&amp;#34;) print(&amp;#34;-------------------- my.out ---------------------&amp;#34;) system(&amp;#34;type my.out&amp;#34;) Powershell #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int main() { int tc=0; while(1) { system(&amp;#34;./E_data &amp;gt; data.in&amp;#34;); system(&amp;#34;cat data.in | ./E_std.exe &amp;gt; std.txt&amp;#34;); system(&amp;#34;cat data.in | ./E.exe &amp;gt; my.txt&amp;#34;); if(system(&amp;#34;diff std.txt my.txt &amp;gt; diff.txt&amp;#34;)) { cout&amp;lt;&amp;lt;&amp;#34;WA&amp;#34;&amp;lt;&amp;lt;endl; break; } else</description>
    </item>
    
    <item>
      <title>[模板][数据结构] 树状数组 Binary Index Tree/Fenwick Tree</title>
      <link>https://ottffyzy.github.io/tpls/ds/bit/</link>
      <pubDate>Thu, 01 Oct 2020 12:09:44 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/ds/bit/</guid>
      <description>树状数组 Binary Index Tree/Fenwick Tree 1d 单点修改，区间询问 // T must + - // id 1~n template&amp;lt;typename T,size_t M,typename OpPlus=plus&amp;lt;T&amp;gt;,typename OpMinus=minus&amp;lt;T&amp;gt;&amp;gt; struct BIT { static int lowbit(int x) { return x&amp;amp;(-x); } constexpr static OpPlus opp{}; constexpr static OpMinus opm{}; static T tmp[M+1]; T tree[M+1]; // tree[i] -&amp;gt; sum of [i-lowbit(i)+1,i] int n; void init(int n_) { n=n_; for(int i=1;i&amp;lt;=n;i++) tree[i]=T(0); } void init(int n_,T v[]) // v[0 ~ n_-1] { n=n_; tmp[0]=T(0); for(int i=1;i&amp;lt;=n;i++) tmp[i]=opp(tmp[i-1],v[i]); for(int i=1;i&amp;lt;=n;i++) tree[i]=opm(tmp[i],tmp[i-lowbit(i)]); // for(int i=0;i&amp;lt;n;i++) add(i,v[i]); } void add(int p,T V) { for(;p&amp;lt;=n;p+=lowbit(p))</description>
    </item>
    
    <item>
      <title>[模板] 计时 Timing</title>
      <link>https://ottffyzy.github.io/tpls/others/timing/</link>
      <pubDate>Thu, 01 Oct 2020 00:08:34 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/others/timing/</guid>
      <description>计时 Timing chrono class Timing { private: typedef chrono::time_point&amp;lt;std::chrono::high_resolution_clock&amp;gt; TP; TP current_time() { return chrono::high_resolution_clock::now(); } TP st,ed; public: void start() { st=current_time(); } void end() { ed=current_time(); } void print() { cout&amp;lt;&amp;lt;chrono::duration_cast&amp;lt;chrono::microseconds&amp;gt;(ed-st).count() &amp;lt;&amp;lt;&amp;#34;ms\n&amp;#34;; } }timing;</description>
    </item>
    
    <item>
      <title>[模板] C&#43;&#43; Debug</title>
      <link>https://ottffyzy.github.io/tpls/a/debug/</link>
      <pubDate>Tue, 29 Sep 2020 14:34:12 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/a/debug/</guid>
      <description>C++ 日常使用 template &amp;lt;typename A, typename B&amp;gt; string to_string(pair&amp;lt;A, B&amp;gt; p); template &amp;lt;typename A, typename B, typename C&amp;gt; string to_string(tuple&amp;lt;A, B, C&amp;gt; p); template &amp;lt;typename A, typename B, typename C, typename D&amp;gt; string to_string(tuple&amp;lt;A, B, C, D&amp;gt; p); string to_string(const string&amp;amp; s) { return &amp;#39;&amp;#34;&amp;#39; + s + &amp;#39;&amp;#34;&amp;#39;; } string to_string(const char* s) { return to_string((string) s); } string to_string(bool b) { return (b ? &amp;#34;true&amp;#34; : &amp;#34;false&amp;#34;); } string to_string(vector&amp;lt;bool&amp;gt; v) { string res = &amp;#34;{&amp;#34;; for (int i = 0; i &amp;lt; static_cast&amp;lt;int&amp;gt;(v.size()); i++) { if (i) { res += &amp;#34;, &amp;#34;; } res</description>
    </item>
    
    <item>
      <title>[模板] C&#43;&#43; 日常使用</title>
      <link>https://ottffyzy.github.io/tpls/a/cpp/</link>
      <pubDate>Tue, 29 Sep 2020 14:34:12 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/a/cpp/</guid>
      <description>C++ 日常使用 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int io_=[](){ ios::sync_with_stdio(false); cin.tie(nullptr); return 0; }(); using LL = long long; using ULL = unsigned long long; using LD = long double; using PII = pair&amp;lt;int, int&amp;gt;; using VI = vector&amp;lt;int&amp;gt;; using MII = map&amp;lt;int, int&amp;gt;; template&amp;lt;typename T&amp;gt; void cmin(T &amp;amp;x,const T &amp;amp;y) { if(y&amp;lt;x) x=y; } template&amp;lt;typename T&amp;gt; void cmax(T &amp;amp;x,const T &amp;amp;y) { if(x&amp;lt;y) x=y; } template&amp;lt;typename T&amp;gt; void cmin(T &amp;amp;x,T &amp;amp;y,const T &amp;amp;z) {// x&amp;lt;=y&amp;lt;=z if(z&amp;lt;x) { y=x; x=z; } else if(z&amp;lt;y) y=z; } template&amp;lt;typename T&amp;gt; void cmax(T &amp;amp;x,T &amp;amp;y,const T &amp;amp;z) {// x&amp;gt;=y&amp;gt;=z if(x&amp;lt;z) { y=x;</description>
    </item>
    
    <item>
      <title>[LeetCode] 值得一做的题目列表</title>
      <link>https://ottffyzy.github.io/summaries/lcgoodproblem/</link>
      <pubDate>Tue, 29 Sep 2020 13:56:21 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/summaries/lcgoodproblem/</guid>
      <description>前 总结一下 LeetCode 上比较好的题目（部分题可能并不是很好，但是实现细节复杂，面试需要特别注意也囊括进来了）。 推荐指数 $1-5$ 是按照可能已经掌握的知识层次进行排序的，竞赛选手推荐刷推荐指数 $3$ 以上的题目。推荐指数和难度</description>
    </item>
    
    <item>
      <title>[模板][Hash] 安全哈希函数</title>
      <link>https://ottffyzy.github.io/tpls/hash/safehash/</link>
      <pubDate>Mon, 28 Sep 2020 22:00:50 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/hash/safehash/</guid>
      <description>安全哈希函数 struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c x += 0x9e3779b97f4a7c15; x = (x ^ (x &amp;gt;&amp;gt; 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x &amp;gt;&amp;gt; 27)) * 0x94d049bb133111eb; return x ^ (x &amp;gt;&amp;gt; 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } }; 用这个函数作为 unordered_set 的第二个参数或 unordered_map 的第三个参数。</description>
    </item>
    
    <item>
      <title>[模板][数论] 模下计算</title>
      <link>https://ottffyzy.github.io/tpls/nt/mod/</link>
      <pubDate>Sun, 27 Sep 2020 23:19:53 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/nt/mod/</guid>
      <description>模下计算 普通 const int MO=1e9+7; inline int add(int x,int y) { x+=y; if(x&amp;gt;=MO) x-=MO; return x; } inline int sub(int x,int y) { x-=y; if(x&amp;lt;0) x+=MO; return x; } inline int mul(int x,int y) { return 1LL*x*y%MO; } inline void addv(int &amp;amp;x,int y) { x+=y; if(x&amp;gt;=MO) x-=MO; } inline void subv(int &amp;amp;x,int y) { x-=y; if(x&amp;lt;0) x+=MO; } inline void mulv(int &amp;amp;x,int y) { x=1LL*x*y%MO; } int qp(int x,int n) { int ans=1; while(n) { if(n&amp;amp;1) { mulv(ans,x); } mulv(x,x); n&amp;gt;&amp;gt;=1; } return ans; } ModInt template&amp;lt;int MO=1000000007&amp;gt; struct ModInt { int x; ModInt(int x=0):x(x){ norm();</description>
    </item>
    
    <item>
      <title>[模板][数据结构] 左偏树 Leftist Tree</title>
      <link>https://ottffyzy.github.io/tpls/ds/leftist/</link>
      <pubDate>Sun, 27 Sep 2020 19:07:04 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/ds/leftist/</guid>
      <description>左偏树 Leftist Tree // min leftist tree // T must define &amp;lt; // M: the size of the heap template&amp;lt;typename T,size_t M,typename Cmp=less&amp;lt;T&amp;gt;&amp;gt; struct Leftist { static Cmp cmp; T val[M]; int l[M],r[M],d[M]; int nn; // number of node void init() { nn=0; } // using val to build a leftist tree // return the id of the root int build(int n,T val_[]) { queue&amp;lt;int&amp;gt; qu; for(int i=1;i&amp;lt;=n;i++) qu.push(i); int u,v; while(qu.size()&amp;gt;1) { u=qu.front(); qu.pop(); v=qu.front(); qu.pop(); merge(u,v); qu.push(u); } return qu.front(); } int newtree(T v) { val[++nn]=v; r[nn]=l[nn]=d[nn]=0; return nn; } void merge(int &amp;amp;x,int y) // merge</description>
    </item>
    
    <item>
      <title>[模板][图论] 克鲁斯卡尔 Kruskal</title>
      <link>https://ottffyzy.github.io/tpls/gt/kruskal/</link>
      <pubDate>Fri, 25 Sep 2020 16:25:48 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/gt/kruskal/</guid>
      <description>克鲁斯卡尔 Kruskal template&amp;lt;typename T,size_t V,size_t E&amp;gt; struct Kruskal { typedef tuple&amp;lt;T,int,int&amp;gt; Edge; typedef pair&amp;lt;T,int&amp;gt; PTI; Edge edges[E]; int inmst[E]; int n; // number of vertex int m; // number of edge int uf[V]; int find(int x) { return x==uf[x]?x:uf[x]=find(uf[x]); } void init(int n_) { n=n_; m=0; } void addedge(int u,int v,T w) { edges[m++]={w,u,v}; } PTI solve() { int cnt=n; // number of connected component T sum=0; int u,v; T w; for(int i=0;i&amp;lt;n;i++) uf[i]=i; sort(edges,edges+m); for(int i=0;i&amp;lt;m&amp;amp;&amp;amp;cnt&amp;gt;1;i++) { tie(w,u,v)=edges[i]; u=find(u); v=find(v); if(u==v) continue; inmst[i]=1; sum=sum+w; cnt--; uf[u]=v; } return {sum,cnt==1}; // {totval in mst, ismst} }</description>
    </item>
    
    <item>
      <title>[模板][图论] 弗洛伊德 Floyd</title>
      <link>https://ottffyzy.github.io/tpls/gt/floyd/</link>
      <pubDate>Fri, 25 Sep 2020 15:07:23 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/gt/floyd/</guid>
      <description>弗洛伊德 Floyd // T must define &amp;lt; and + template&amp;lt;typename T,size_t V,bool Directed=true,T INF=T(0x3f3f3f3f)&amp;gt; struct Floyd { T g[V][V]; int n; void init(int n_) { n=n_; for(int i=0;i&amp;lt;n;i++) for(int j=0;j&amp;lt;n;j++) g[i][j]=INF; } void addedge(int u,int v,T w) // check multi-edges { g[u][v]=w; if(!Directed) g[v][u]=w; } void cmin(T &amp;amp;x,const T &amp;amp;y) { if(y&amp;lt;x) x=y; } void floyd(Upd =upd) { for(int k=0;k&amp;lt;n;k++) for(int i=0;i&amp;lt;n;i++) for(int j=0;j&amp;lt;n;j++) cmin(g[i][j],g[i][k]+g[k][j]); } };</description>
    </item>
    
    <item>
      <title>[模板][数据结构] 并查集 Union Find / Disjoint Set Union</title>
      <link>https://ottffyzy.github.io/tpls/ds/unionfind/</link>
      <pubDate>Thu, 24 Sep 2020 23:18:06 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/ds/unionfind/</guid>
      <description>并查集 Union Find / Disjoint Set Union 路径压缩和按 size 合并 Union by Size // M: max number of set // id is in [0~M-1] template&amp;lt;size_t M&amp;gt; struct UF { int uf[M],sz[M]; int n; int ns; // number of set void init(int n_) { n=ns=n_; for(int i=0;i&amp;lt;n;i++) uf[i]=i,sz[i]=1; } int find(int x) { return x==uf[x]?x:uf[x]=find(uf[x]); } bool same(int x,int y) { return find(x)==find(y); } bool merge(int x,int y) { x=find(x); y=find(y); if(x==y) return false; if(sz[x]&amp;gt;sz[y]) swap(x,y); sz[y]+=sz[x]; uf[x]=y; ns--; return true; } }; Debug: void show() { cerr&amp;lt;&amp;lt;&amp;#34;UnionFind:----------------------\n&amp;#34;; cerr&amp;lt;&amp;lt;&amp;#34;id:&amp;#34;; for(int i=0;i&amp;lt;n;i++) cerr&amp;lt;&amp;lt;&amp;#39;\t&amp;#39;&amp;lt;&amp;lt;i; cerr&amp;lt;&amp;lt;&amp;#39;\n&amp;#39;;</description>
    </item>
    
    <item>
      <title>[模板][图论] 迪杰斯特拉 Dijkstra</title>
      <link>https://ottffyzy.github.io/tpls/gt/dijkstra/</link>
      <pubDate>Thu, 24 Sep 2020 19:10:04 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/gt/dijkstra/</guid>
      <description>迪杰斯特拉 Dijkstra 模板（priority_queue） // T must define &amp;lt; and + // V: max number of vertex [0~V-1] template&amp;lt;typename T,size_t V,bool Directed=true, T INF=T(0x3f3f3f3f),T ZERO=T(0)&amp;gt; struct G { typedef pair&amp;lt;T,int&amp;gt; PTI; vector&amp;lt;PTI&amp;gt; g[V]; T dis[V]; int vis[V]; int n; void init(int n_) { n=n_; for(int i=0;i&amp;lt;n;i++) g[i].clear(); } void addedge(int u,int v,T w) { g[u].emplace_back(w,v); if(!Directed) g[v].emplace_back(w,u); } void dijkstra(int st,int ed=-1) // ed=-1 no destination { for(int i=0;i&amp;lt;n;i++) dis[i]=INF,vis[i]=0; priority_queue&amp;lt;PTI,vector&amp;lt;PTI&amp;gt;,greater&amp;lt;PTI&amp;gt; &amp;gt; qu; dis[st]=ZERO; qu.emplace(ZERO,st); while(!qu.empty()) { PTI p=qu.top(); qu.pop();</description>
    </item>
    
    <item>
      <title>[模板][数据结构] 二叉堆 Binary Heap</title>
      <link>https://ottffyzy.github.io/tpls/ds/binaryheap/</link>
      <pubDate>Wed, 23 Sep 2020 23:12:58 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/ds/binaryheap/</guid>
      <description>二叉堆 Binary Heap 模板：普通二叉堆 Heap // T must define &amp;lt; // min heap // M: max size of heap template&amp;lt;typename T,size_t M,typename Cmp=less&amp;lt;T&amp;gt;&amp;gt; struct Heap { static Cmp cmp; T h[M+1]; int n; void init() { n=0; } void init(T h_[],int n_) // h[0~n-1] { n=n_; for(int i=1;i&amp;lt;=n;i++) h[i]=h_[i-1]; for(int i=n/2;i;i--) sink(i); // O(n) } void push(T x) { h[++n]=x; swim(n); } T pop() { T res=h[1]; h[1]=h[n--]; sink(1); return res; } T top() { return h[1]; } // check n&amp;gt;=1 int size() { return n; } bool empty() { return</description>
    </item>
    
    <item>
      <title>[LeetCode] LCP 21. 追逐游戏</title>
      <link>https://ottffyzy.github.io/sols/leetcode/lcp21/</link>
      <pubDate>Fri, 18 Sep 2020 22:10:05 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/leetcode/lcp21/</guid>
      <description>LCP 21. 追逐游戏 题目大意 给定一棵 $N$ 个点的基环树（环套树）。给定图上两个起始位置 $A$ 和 $B$ ($A \neq B$)。每一轮 $A$ 先移动，$B$ 后移动。每次移动可以移动到图上当前点的相邻点或者保持不动。任意时刻如果 $A$ 和 $B$ 处在同一位</description>
    </item>
    
    <item>
      <title>《C&#43;&#43; Primer》 拾遗 第 1 章 开始</title>
      <link>https://ottffyzy.github.io/notes/cppprimer/c1/</link>
      <pubDate>Thu, 17 Sep 2020 14:07:57 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/cppprimer/c1/</guid>
      <description>第 1 章 开始 1.1 查看程序返回值 当一个程序运行结束时，我们想知道 main 函数的返回值可以使用以下命令。 Win &amp;gt; echo %ERRORLEVEL% Unix $ echo $? 1.2 标准库有四个输入输出对象 cin // 标准输入 cout // 标准输出 cerr // 标准错误 clog // 输出程序运行时的一般信息 字面</description>
    </item>
    
    <item>
      <title>《概率、统计与随机过程》 笔记 第 1 章 概率论导论</title>
      <link>https://ottffyzy.github.io/notes/probabilitysrp4e/c1/</link>
      <pubDate>Tue, 15 Sep 2020 14:13:07 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/probabilitysrp4e/c1/</guid>
      <description>第 1 章 概率论导论 1.2 概率的不同类型 直观概率：基于直观来处理判断 古典概率：事件概率不是实验性的，通过预先计算事件 $E$ 可能发生的次数 $n_E$ 形成一个比值 $n_E / n$ 其中 $n$ 是所有可能的结果。此时需要所有的结果是等可能的。 古</description>
    </item>
    
    <item>
      <title>《Effective C&#43;&#43;》 笔记 1. 让自己习惯 C&#43;&#43;</title>
      <link>https://ottffyzy.github.io/notes/effectivecpp/c1/</link>
      <pubDate>Sun, 13 Sep 2020 22:07:50 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/effectivecpp/c1/</guid>
      <description>1. 让自己习惯 C++ 条款 01：视 C++ 为一个语言联邦 C++ 是一个多重泛型编程语言（multiparadigm programming language）。 C++ 同时支持过程（procedural）形式、面向对象（object-oriented</description>
    </item>
    
    <item>
      <title>《汇编语言》 笔记  实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</title>
      <link>https://ottffyzy.github.io/notes/assemblylanguage/e1/</link>
      <pubDate>Thu, 10 Sep 2020 19:08:42 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/assemblylanguage/e1/</guid>
      <description>实验 1 查看 CPU 和内存，用机器指令和汇编指令编程 想在 win10 上玩这个需要自己下载 DOSBox 和 debug.exe。 之后用 DOSBox 运行 debug 即可开始书中的实验。 R 命令：查看、修改寄存器 进入 debug 模式后输入 $r$ 回车后可以查看 CPU 寄存器内容。 输</description>
    </item>
    
    <item>
      <title>[Luogu] P4588 [TJOI2018]数学计算</title>
      <link>https://ottffyzy.github.io/sols/luogu/p4588/</link>
      <pubDate>Wed, 09 Sep 2020 01:48:20 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/luogu/p4588/</guid>
      <description>P4588 [TJOI2018]数学计算 题目大意 给定 $x = 1$ 和某个模数 $MO$，有两种操作（共 $Q \le 10^5$ 次） 操作 $1$：把 $x = x*v % MO$ 操作 $2$：取消第 $k$ 次操作（取消的必为操作 $1$，且某个操作 $1$ 只会最多被取消一次） 每</description>
    </item>
    
    <item>
      <title>《汇编语言》 笔记 第 2 章 寄存器</title>
      <link>https://ottffyzy.github.io/notes/assemblylanguage/c2/</link>
      <pubDate>Tue, 08 Sep 2020 18:44:17 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/assemblylanguage/c2/</guid>
      <description>第 2 章 寄存器 在 CPU 中： 运算器处理信息 寄存器储存信息 控制器控制各种器件 内部总线连接各种器件，在他们之间传输数据 对汇编程序员最重要的部件就是寄存器，寄存器是程序员可以用指令读写的部件，程序员通过改变寄存器中</description>
    </item>
    
    <item>
      <title>《汇编语言》 笔记 第 1 章 基础知识</title>
      <link>https://ottffyzy.github.io/notes/assemblylanguage/c1/</link>
      <pubDate>Tue, 08 Sep 2020 18:01:38 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/assemblylanguage/c1/</guid>
      <description>第 1 章 基础知识 1.1 机器语言 CPU 提供机器指令集也就是机器语言。 早期卡片打孔就是使用的机器语言。 机器语言难于书写阅读查错于是产生了汇编语言 1.2 汇编语言的产生 汇编语言的主题是汇编指令。汇编指令采用了更便于人类书写</description>
    </item>
    
    <item>
      <title>[AtCoder] Beginner Contest 176 E - Bomber</title>
      <link>https://ottffyzy.github.io/sols/atcoder/abc176/e/</link>
      <pubDate>Tue, 08 Sep 2020 00:36:26 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/atcoder/abc176/e/</guid>
      <description>E - Bomber 题目大意 给出一个 $H \times W$ 的矩阵，上面有 $M$ 个点，选出一行一列使得覆盖到的点最多。问最多是多少。 其中 $H,W,M &amp;lt;= 3 \times 10^5$ 简要题解 注意到一定会贪心的选某个数量最多的行和列。设其行列数量分别 $mx$，$my$，则答</description>
    </item>
    
    <item>
      <title>[LeetCode] 1575. Count All Possible Routes</title>
      <link>https://ottffyzy.github.io/sols/leetcode/p1575/</link>
      <pubDate>Mon, 07 Sep 2020 23:19:19 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/leetcode/p1575/</guid>
      <description>1575. Count All Possible Routes 题目大意 给定一些不同的位置 $(N \le 100)$，给定起点和终点位置的标号，给定起始油量 $(F \le 200)$。 每次可以选择从当前位置走到任意其他位置花费每单位距离 $1$ 单位油。油量不能为负。 问，从起点到终点总</description>
    </item>
    
    <item>
      <title>[AtCoder] Beginner Contest 177 E - Coprime</title>
      <link>https://ottffyzy.github.io/sols/atcoder/abc177/e/</link>
      <pubDate>Sat, 05 Sep 2020 01:40:51 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/atcoder/abc177/e/</guid>
      <description>E - Coprime 题目大意 给出数组 $A$ 如果其中数字两两互质则返回 “pairwise coprime”，如果整个数组 $gcd$ 为 $1$ 则返回 “setwise coprime”，其他情况返回 “not coprime” 简要题解 显然 setwise 很好判</description>
    </item>
    
    <item>
      <title>[AtCoder] Beginner Contest 177</title>
      <link>https://ottffyzy.github.io/contests/atcoder/abc177/</link>
      <pubDate>Sat, 05 Sep 2020 01:26:32 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/contests/atcoder/abc177/</guid>
      <description>比赛简述 ABC 中比较简单的一场，题目也都比较常规 AtCoder Beginner Contest 177 A - Don&amp;rsquo;t be late 代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int main() { int d,t,s; scanf(&amp;#34;%d%d%d&amp;#34;,&amp;amp;d,&amp;amp;t,&amp;amp;s); printf(&amp;#34;%s\n&amp;#34;,t*s&amp;gt;=d ? &amp;#34;Yes&amp;#34; : &amp;#34;No&amp;#34;); return 0; } B - Substring 题目大意 给出两个串 $S$ 和 $T$，问 $S$ 至少替换多少字符可以使 $T$ 是 $S$ 的子串。 Tag: 暴力 简要题解 $S$ $T$</description>
    </item>
    
    <item>
      <title>[AtCoder] Beginner Contest 177 F - I hate Shortest Path Problem</title>
      <link>https://ottffyzy.github.io/sols/atcoder/abc177/f/</link>
      <pubDate>Fri, 04 Sep 2020 02:37:10 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/atcoder/abc177/f/</guid>
      <description>F - I hate Shortest Path Problem 题目大意 给出一个 $(h+1) \times w$ 的二维矩阵，初始位置可以是第 $0$ 行的任意位置。 每一个格只能往右或下方向移动 每一行 $i$ 区间 $L_{i}$ 到 $R_{i}$ 的格子不能向下走，问到达每一行的最小可能步数 简要题解 $dp[i][j]$ 为到达 $(i,j)$ 位置的最小步</description>
    </item>
    
    <item>
      <title>使用 Typora 写 Markdown</title>
      <link>https://ottffyzy.github.io/notes/markdown/</link>
      <pubDate>Thu, 03 Sep 2020 21:53:13 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/notes/markdown/</guid>
      <description>0 简介 Markdown 与 Typora 什么是 Markdown？ Markdown 是一种轻量级标记语言，可以通过格式标记把普通文本变成带有格式的富文本。 什么是 Typora？ Typora 是使用 Markdown 语言的一个编辑器。与其他 Markdown 编辑器不同的是，Markdown 的效</description>
    </item>
    
    <item>
      <title>OTTFF 的新 Blog</title>
      <link>https://ottffyzy.github.io/others/helloworld/</link>
      <pubDate>Thu, 03 Sep 2020 21:08:19 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/others/helloworld/</guid>
      <description>OTTFF 的新 Blog 很久之前我有一个 xxdn 的 Blog，但是随着自己越来越懒其广告等不重要的信息越来越多，于是弃坑多年。 读到一些大牛自建的博客之后，也萌生了自己搭建一个界面简单干净而又功能强大的 Blog 的想法。 经过研究，大概</description>
    </item>
    
  </channel>
</rss>
