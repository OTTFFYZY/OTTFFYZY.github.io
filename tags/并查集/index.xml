<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>并查集 on OTTFF&#39;s Blog</title>
    <link>https://ottffyzy.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
    <description>Recent content in 并查集 on OTTFF&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 23 Feb 2025 23:02:44 -0800</lastBuildDate><atom:link href="https://ottffyzy.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[CF] E. Mycraft Sand Sort - Codeforces Round 1005 (Div. 2)</title>
      <link>https://ottffyzy.github.io/sols/codeforces/2064/e/</link>
      <pubDate>Sun, 23 Feb 2025 23:02:44 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/2064/e/</guid>
      <description>https://codeforces.com/contest/2064/problem/E 题目大意 给出 $n$ 长的排列 $p$ 和 $n$ 长的颜色数组 $c$。从上到下，从 $i = 1 \sim n$ 将 $p_i$ 个颜色为 $c_i$ 的左侧对齐横向排列，之后让其按照重力规则下落，问有多少个不同的排列和颜色方案的二元组，可以得到和题目给出的排列颜色</description>
    </item>
    
    <item>
      <title>[CF] E. Graph Composition - Codeforces Round 998 (Div. 3)</title>
      <link>https://ottffyzy.github.io/sols/codeforces/2060/e/</link>
      <pubDate>Sun, 19 Jan 2025 23:58:39 -0800</pubDate>
      
      <guid>https://ottffyzy.github.io/sols/codeforces/2060/e/</guid>
      <description>https://codeforces.com/contest/2060/problem/E 题目大意 给出无向图 $F$ 和 $G$。可以对 F 进行操作：增加一条边或删除一条边的操作。 问至少需要多少次使得 $F$ 中任意两点 $u, v$ 有路径当且仅当 $G$ 中对应两点有路径。 给出 $F$ 和 $G$ 的点数 $n \ (\le 2 \times 10^5)$ 和各自的边数 $m_1, m_2 \ (0 \le</description>
    </item>
    
    <item>
      <title>[模板][数据结构] 并查集 Union Find / Disjoint Set Union</title>
      <link>https://ottffyzy.github.io/tpls/ds/unionfind/</link>
      <pubDate>Thu, 24 Sep 2020 23:18:06 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/tpls/ds/unionfind/</guid>
      <description>并查集 Union Find / Disjoint Set Union 路径压缩和按 size 合并 Union by Size // M: max number of set // id is in [0~M-1] template&amp;lt;size_t M&amp;gt; struct UF { int uf[M],sz[M]; int n; int ns; // number of set void init(int n_) { n=ns=n_; for(int i=0;i&amp;lt;n;i++) uf[i]=i,sz[i]=1; } int find(int x) { return x==uf[x]?x:uf[x]=find(uf[x]); } bool same(int x,int y) { return find(x)==find(y); } bool merge(int x,int y) { x=find(x); y=find(y); if(x==y) return false; if(sz[x]&amp;gt;sz[y]) swap(x,y); sz[y]+=sz[x]; uf[x]=y; ns--; return true; } }; Debug: void show() { cerr&amp;lt;&amp;lt;&amp;#34;UnionFind:----------------------\n&amp;#34;; cerr&amp;lt;&amp;lt;&amp;#34;id:&amp;#34;; for(int i=0;i&amp;lt;n;i++) cerr&amp;lt;&amp;lt;&amp;#39;\t&amp;#39;&amp;lt;&amp;lt;i; cerr&amp;lt;&amp;lt;&amp;#39;\n&amp;#39;;</description>
    </item>
    
    <item>
      <title>[AtCoder] Beginner Contest 177</title>
      <link>https://ottffyzy.github.io/contests/atcoder/abc177/</link>
      <pubDate>Sat, 05 Sep 2020 01:26:32 -0400</pubDate>
      
      <guid>https://ottffyzy.github.io/contests/atcoder/abc177/</guid>
      <description>比赛简述 ABC 中比较简单的一场，题目也都比较常规 AtCoder Beginner Contest 177 A - Don&amp;rsquo;t be late 代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int main() { int d,t,s; scanf(&amp;#34;%d%d%d&amp;#34;,&amp;amp;d,&amp;amp;t,&amp;amp;s); printf(&amp;#34;%s\n&amp;#34;,t*s&amp;gt;=d ? &amp;#34;Yes&amp;#34; : &amp;#34;No&amp;#34;); return 0; } B - Substring 题目大意 给出两个串 $S$ 和 $T$，问 $S$ 至少替换多少字符可以使 $T$ 是 $S$ 的子串。 Tag: 暴力 简要题解 $S$ $T$</description>
    </item>
    
  </channel>
</rss>
