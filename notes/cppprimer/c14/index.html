<!DOCTYPE html>
<html>
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  《C&#43;&#43; Primer》 拾遗 第 14 章 重载运算与类型转换 &ndash; OTTFF&#39;s Blog

    </title>
    
    
    <meta name="description" property="og:description" content="第 14 章 重载运算与类型转换 14.1 基本概念 重载的运算符是具有特殊名字的函数。 重载运算符的参数数量与该运算符作用的运算对象数量一样多。除了重载的函数调用运算符 operator() 之外其他重载运算符不能含有默认实参。 一个重载运算符|OTTFF&#39;s Blog">
    

    <meta name="apple-mobile-web-app-title" content="OTTFF&#39;s Blog">
    
    
    
    


    <link rel="stylesheet" href="/assets/syntax.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style.css">
    <link rel="stylesheet" href="/assets/github-gist.css">
    <link rel="stylesheet" href="/assets/copy-to-clipboard.css">
    
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">

      <div id="header" class="px-1 bg-white">
        <nav class="UnderlineNav UnderlineNav--right px-2">
  <a class="UnderlineNav-actions muted-link h2" href="https://ottffyzy.github.io/">
    OTTFF&#39;s Blog
  </a>

  
  
  <div class="UnderlineNav-body">
    
      
      
      <a class="UnderlineNav-item " href="/">
        
        <span>Home</span>
      </a>
      
    
      
      
      <a class="UnderlineNav-item " href="/templates">
        
        <span>Templates</span>
      </a>
      
    
      
      
      <a class="UnderlineNav-item " href="/categories/contests">
        
        <span>Contests</span>
      </a>
      
    
      
      
      <a class="UnderlineNav-item " href="/sols">
        
        <span>Solutions</span>
      </a>
      
    
      
      
      <a class="UnderlineNav-item " href="/categories/notes">
        
        <span>Notes</span>
      </a>
      
    
  </div>
  
</nav>

      </div>

      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">《C&#43;&#43; Primer》 拾遗 第 14 章 重载运算与类型转换</div>
  </div>
  <div class="Subhead-description">
    

<a href='/categories/notes' class="muted-link">
  <span class="Label Label--gray-darker">Notes</span>
</a>









<a href='/series/cpp-primer' class="muted-link">
  <span class="Label Label--gray">Cpp Primer</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2021-08-01. Published at: 2021-08-01.">
        
          Published: 2021-08-01 周日 00:46:07
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom markdown">
      <h2 id="第-14-章-重载运算与类型转换">第 14 章 重载运算与类型转换</h2>
<h3 id="141-基本概念">14.1 基本概念</h3>
<p>重载的运算符是具有特殊名字的函数。</p>
<p>重载运算符的参数数量与该运算符作用的运算对象数量一样多。除了重载的函数调用运算符 operator() 之外其他重载运算符不能含有默认实参。</p>
<p>一个重载运算符函数是成员函数时，左侧运算对象绑定到隐式的 this 指针上，此时显式的参数个数要比运算符的对象数少 1。</p>
<p>对于一个运算符函数，它至少有一个类类型的参数。（不能重载作用于内置类型的运算符）。</p>
<p>我们只能重载现有的运算符，无法发明新的运算符。</p>
<p>不能改变现有运算符的优先级和结合律。</p>
<p>可以重载的运算符</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="o">+</span>   <span class="o">-</span>   <span class="o">*</span>   <span class="o">/</span>   <span class="o">%</span>   <span class="o">^</span>
<span class="o">&amp;</span>   <span class="o">|</span>   <span class="o">~</span>   <span class="o">!</span>   <span class="p">,</span>   <span class="o">=</span>
<span class="o">&lt;</span>   <span class="o">&gt;</span>   <span class="o">&lt;=</span>  <span class="o">&gt;=</span>  <span class="o">++</span>  <span class="o">--</span>
<span class="o">&lt;&lt;</span>  <span class="o">&gt;&gt;</span>  <span class="o">==</span>  <span class="o">!=</span>  <span class="o">&amp;&amp;</span>  <span class="o">||</span>
<span class="o">+=</span>  <span class="o">-=</span>  <span class="o">/=</span>  <span class="o">%=</span>  <span class="o">^=</span>  <span class="o">&amp;=</span>
<span class="o">|=</span>  <span class="o">*=</span>  <span class="o">&lt;&lt;=</span> <span class="o">&gt;&gt;=</span> <span class="p">[]</span>  <span class="p">()</span>
<span class="o">-&gt;</span>  <span class="o">-&gt;*</span> <span class="k">new</span> <span class="k">new</span><span class="p">[]</span> <span class="k">delete</span> <span class="k">delete</span><span class="p">[]</span>
</code></pre></div><p>不能重载的运算符</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="o">::</span> 
<span class="p">.</span><span class="o">*</span>
<span class="p">.</span> 
<span class="o">?:</span>
</code></pre></div><p>我们可以像调用普通函数一样调用重载运算符</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// 两种形式等价
</span><span class="c1"></span><span class="n">a</span><span class="p">.</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="n">a</span> <span class="o">+=</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div><h5 id="某些算符不应该被重载">某些算符不应该被重载</h5>
<p>因为重载运算符本质上是函数调用，因此无法保留求职顺序的规则。例如逻辑运算符的短路特性。因此不建议重载逻辑运算符，同时不建议重载逗号运算符和取地址运算符。</p>
<h5 id="选择作为成员或者非成员">选择作为成员或者非成员</h5>
<p>赋值 <code>=</code>、下标 <code>[]</code>、调用 <code>()</code> 和成员访问箭头 <code>-&gt;</code> 必须是成员。</p>
<p>复合赋值运算符一般来说应该是成员，但并非必须。</p>
<p>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符通常应该是成员。</p>
<p>具有对称性的运算符可能转换任意一段的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。如果运算对象时混合类型的则需要定义为非成员函数。</p>
<h3 id="142-输入和输出运算符">14.2 输入和输出运算符</h3>
<p>输出类运算符尽量不要考虑格式化操作。</p>
<p>输入输出运算符必须是非成员函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">s</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">;</span> <span class="c1">// check input state
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;read A failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">is</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;(&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;,&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;)&#34;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>输入需要检查读入是否成功，输出则不需要。</p>
<h5 id="标示错误">标示错误</h5>
<p>一般来说即便输入是成功的，但数据可能依旧不合法（针对具体的功能），输入运算符需要检测数据是否符合设计。此时可以设置流状态来标示失败信息。可以设置 failbit、eofbit 或者 badbit。</p>
<h3 id="143-算术和关系运算符">14.3 算术和关系运算符</h3>
<p>如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况应该使用赋值来实现算术运算符。</p>
<h4 id="1431-相等运算符">14.3.1 相等运算符</h4>
<p><code>==</code> 应该具有传递性。</p>
<p>定义了 <code>==</code> 则也应该定义 <code>!=</code> 并且应该把其中一个的实现委托给另一个。</p>
<h4 id="1432-关系运算符">14.3.2 关系运算符</h4>
<p>注意 <code>&lt;</code> 的定义应当与 <code>==</code> 一致。</p>
<h3 id="145-下标运算符">14.5 下标运算符</h3>
<p>通常下标运算符会有两个版本，返回普通引用、作为常量成员返回常量引用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>
	<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">A</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
	<span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
	
	<span class="k">const</span> <span class="n">A</span> <span class="n">b</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="146-递增和递减运算符">14.6 递增和递减运算符</h3>
<p>前置版本应该返回递增或递减后对象的引用。</p>
<p>为了区分前置和后置运算符，后置版本将接受一个额外的（不被使用的）int 类型的形参。编译器会为这个形参提供一个值为 0 的实参。尽管语法上可以使用这个额外的形参，但是实际通常不会这么做。显式调用时需要给出这个参数来调用后置运算符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>   <span class="c1">// 前置
</span><span class="c1"></span>    <span class="n">A</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// 后置
</span><span class="c1"></span><span class="p">};</span>
<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">();</span>
<span class="n">a</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div><p>可以把后置运算符的定义委托给前置运算符。</p>
<h3 id="147-成员访问运算符">14.7 成员访问运算符</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
	<span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;a function</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">AP</span> <span class="p">{</span>
	<span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
	<span class="n">AP</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
	<span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">A</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">APP</span> <span class="p">{</span>
	<span class="n">AP</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span>
	<span class="n">APP</span><span class="p">(</span><span class="n">AP</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">p</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span>
	<span class="n">AP</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">AP</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">A</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">AP</span> <span class="n">p</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">).</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">).</span><span class="n">func</span><span class="p">();</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">();</span>

	<span class="n">APP</span> <span class="n">pp</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">**</span><span class="n">pp</span><span class="p">).</span><span class="n">i</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>重载的 <code>operator*</code> 不一定是类的成员，也可以自己定义一些操作。</p>
<p>箭头运算符则不能改变获取成员这个事实。</p>
<p>形如 <code>point-&gt;mum</code> 的表达式，point 必须是指向类对象的指针或者是一个重载了 operator-&gt; 的类。它将分别等价于以下形式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="p">(</span><span class="o">*</span><span class="n">point</span><span class="p">).</span><span class="n">mem</span><span class="p">;</span>             <span class="c1">// point 是指针
</span><span class="c1"></span><span class="n">point</span><span class="p">.</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">;</span>  <span class="c1">// point 是类
</span></code></pre></div><p>这也解释了上面程序中 <code>pp-&gt;i</code> 会链式调用的原因。</p>
<h3 id="148-函数调用运算符">14.8 函数调用运算符</h3>
<p>如果类定义了调用运算符，则该类的对象称作函数对象 <code>function object</code>。</p>
<h5 id="含有状态的函数对象类">含有状态的函数对象类</h5>
<p>因为作为对象可以保存一些状态，因此函数对象使用起来比函数更灵活。</p>
<p>泛型对象也经常作为泛型算法的实参。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">PrintString</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
  	<span class="n">PrintString</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">o</span> <span class="o">=</span> <span class="n">cout</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
  		<span class="o">:</span> <span class="n">os</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">sep</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{}</span>
  	<span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">sep</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">private</span><span class="o">:</span>
  	<span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">;</span>
  	<span class="kt">char</span> <span class="n">sep</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;3&#34;</span><span class="p">,</span> <span class="s">&#34;5&#34;</span><span class="p">,</span> <span class="s">&#34;7&#34;</span><span class="p">,</span> <span class="s">&#34;9&#34;</span><span class="p">};</span>
	<span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">PrintString</span><span class="p">(</span><span class="n">cerr</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h4 id="1481-lambda-是函数对象">14.8.1 lambda 是函数对象</h4>
<p>编译器会将 lambda 翻译成一个未命名类的未命名对象。在 lambda 表达式产生的类中含有一个重载的函数调用运算符，它的形参列表和函数体与 lambda 表达式完全一样。默认情况下 lambda 不能改变它捕获的变量，在此情况下，该函数调用运算符是一个 const 成员函数。如果 lambda 被声明为可变的，则调用运算符就不是 const 的了。</p>
<p>通过引用捕获变量时，由成语确保 lambda 执行时引用所引的对象确实存在。编译器可以直接使用该引用而无须在 lambda 产生的类中将其储存为数据成员。</p>
<p>通过值捕获的变量被拷贝到 lambda 中。lambda 产生的类必须为每个值捕获的变量建立数据成员，同时创建构造函数，其使用捕获的变量的值来初始化数据成员。</p>
<p>lambda 表达式产生的类不含默认构造函数、赋值运算符及默认析构函数；是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。</p>
<h4 id="1482-标准库定义的函数对象">14.8.2 标准库定义的函数对象</h4>
<p>在 functional 头文件中</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">plus</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">minus</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">multiplies</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">divides</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">modulus</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">negate</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">equal_to</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">not_equal_to</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">greater_equal</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">less_equal</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">logical_and</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">logical_or</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">logical_not</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</code></pre></div><p>特别的，标准库规定其函数对象对于指针同样适用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span> <span class="o">*&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="c1">// sort(vec.begin(), vec.end(), [](string *a, string *b){
</span><span class="c1">//     return a &lt; b; }); // 未定义行为
</span><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">string</span> <span class="o">*&gt;</span><span class="p">());</span>
</code></pre></div><h4 id="1483-可调用对象与-function">14.8.3 可调用对象与 function</h4>
<p>C++ 中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类对象。</p>
<p>和其他对象一样，可调用的对象也有类型。lambda 有它自己唯一的类类型。函数及函数指针的类型由返回值类型和实参类型决定。</p>
<p>两个不同类型的可调用对象可能共享同一种调用形式 <code>call signature</code>。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型。</p>
<p>有时我们可以使用函数表 <code>function table</code> 来存储指向可调用对象的“指针”。</p>
<p>如果我们使用如下形式，则只能存储函数指针</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">binops</span><span class="p">;</span>
</code></pre></div><h5 id="标准库-function-类型">标准库 function 类型</h5>
<p>function 定义在 functional 头文件中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">;</span> <span class="c1">// T 是 retType(args)
</span><span class="c1"></span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
<span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span> <span class="c1">// obj 可以是任何的可调用对象
</span><span class="c1"></span><span class="n">f</span><span class="p">;</span>                  <span class="c1">// 返回 f 是否为空
</span><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>            <span class="c1">// 调用 f
</span><span class="c1"></span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result_type</span><span class="p">;</span>
<span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">argument_type</span><span class="p">;</span>
<span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">first_argument_type</span><span class="p">;</span>
<span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">second_argument_type</span><span class="p">;</span>
</code></pre></div><h5 id="重载函数与-function">重载函数与 function</h5>
<p>注意重载函数我们无法直接用函数名初始化 function （二义性）。这时我们可以通过函数指针或套一层 lambda 表达式来传入想要的重载函数。</p>
<h3 id="149-重载类型转换与运算符">14.9 重载、类型转换与运算符</h3>
<p>转换构造函数和类型转换运算符共同定义了类类型转换 <code>class type conversions</code>，也称用户定义的类型转换 <code>user-defined conversions</code>。</p>
<h4 id="1491-类型转换运算符">14.9.1 类型转换运算符</h4>
<p>类型转换运算符 <code>conversion operator</code> 是类的一种特殊成员函数，它负责将一个类类型的值准换成其他类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">operator</span> <span class="nf">type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div><p>必须是成员函数，不能声明返回类型，形参列表也必须为空，通常应该是 const 的。</p>
<h5 id="定义含有类型转换运算符的类">定义含有类型转换运算符的类</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">SmallInt</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">SmallInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> 
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">&#34;Bad SmallInt value&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><h5 id="类型转换运算符可能产生意外结果">类型转换运算符可能产生意外结果</h5>
<p>实践中很少提供类型转换运算符。在大多数情况下，如果类型转换自动发生，用户可能会感觉比较意外，而不是感受到了帮助。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
</code></pre></div><p>例如这里 cin 本身没有定义 <code>&lt;&lt;</code> 算符，如果隐式转换存在，这里就可以通过编译，而不是是发生错误。</p>
<h5 id="显式的类型转换运算符">显式的类型转换运算符</h5>
<p>C++11 中引入了显式的类型转换运算符 <code>explicit conversion operator</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">explicit</span> <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><p>编译器通常不会将一个显式的类型转换运算符用于隐式类型转换。除非表达式被用作条件，显式类型转换将被隐式的执行：</p>
<p>if、while 及 do 语句的条件部分</p>
<p>for 语句头的条件表达式</p>
<p>逻辑非运算符 <code>!</code> 、逻辑或运算符 <code>||</code>、逻辑与运算符 <code>&amp;&amp;</code> 的运算对象</p>
<p>条件运算符 <code>?:</code> 的条件表达式</p>
<h4 id="1492-避免有二义性的类型转换">14.9.2 避免有二义性的类型转换</h4>
<p>两种情况下可能出现多重转换路径。第一种情况是两个类提供相同的类型转换：例如，当 A 类定义了一个接受 B 类对象的转换构造函数，同时 B 类定义了一个转换目标是 A 类的类型转换运算符时。</p>
<p>第二种情况是类定义了多个转换规则。</p>
<h5 id="实参匹配和相同的类型转换">实参匹配和相同的类型转换</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">B</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="k">operator</span> <span class="nf">A</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">A</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">B</span> <span class="n">b</span><span class="p">;</span>
<span class="c1">// A a = f(b); // f(B::operator A()) ? f(A::A(const B&amp;)) ?
</span></code></pre></div><p>这时可以使用显示的调用方式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">A</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="k">operator</span> <span class="n">A</span><span class="p">());</span>
<span class="n">A</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
</code></pre></div><p>注意无法用强制类型转换来解决二义性问题，因为强制类型转换本身也面临二义性。</p>
<h5 id="二义性与转换目标为内置类型的多重类型转换">二义性与转换目标为内置类型的多重类型转换</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">operator</span> <span class="nf">double</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span><span class="p">);</span>
<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
<span class="c1">// f(a); // f(A::operator int()) ? f(A::operator double()) ?
</span><span class="c1"></span>
<span class="kt">long</span> <span class="n">lg</span><span class="p">;</span>
<span class="c1">// A a2(lg); // A::A(int) ? A::A(double) ?
</span></code></pre></div><h5 id="重载函数与转换构造函数">重载函数与转换构造函数</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">C</span> <span class="p">{</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">D</span> <span class="p">{</span>
    <span class="n">D</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">manip</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">manip</span><span class="p">(</span><span class="k">const</span> <span class="n">D</span><span class="o">&amp;</span><span class="p">);</span>
<span class="c1">// manip(10);
</span></code></pre></div><h5 id="重载函数与用户定义的类型转换">重载函数与用户定义的类型转换</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">E</span> <span class="p">{</span>
    <span class="n">E</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">manip2</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">manip2</span><span class="p">(</span><span class="k">const</span> <span class="n">E</span><span class="o">&amp;</span><span class="p">);</span>
<span class="c1">// manip(10);
</span></code></pre></div><h4 id="1493-函数匹配与重载运算符">14.9.3 函数匹配与重载运算符</h4>
<p>重载运算符也是重载的函数，也适用于普通函数的匹配规则。</p>
<p>而且也要注意成员函数和非成员函数彼此不会重载。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">SmallInt</span> <span class="p">{</span>
    <span class="k">friend</span> <span class="n">SamllInt</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">SmallInt</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">SmallInt</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">SmallInt</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">SmallInt</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>
<span class="n">SmallInt</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s3</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 二义性错误！
</span></code></pre></div>
  </section>

  <section>
    
        <a href="/tpls/ds/idpool/" class="previous_page">Prev: [模板][数据结构] 下标池 IdPool </a>
    
     <br> 
    
        <a href="/notes/cppprimer/c16/" class="next_page">Next: 《C&#43;&#43; Primer》 拾遗 第 16 章 模板与泛型编程 </a>
    
  </section>

  <section>
    
      
      
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'b60070c8fc2c3e5b67f2',
    clientSecret: '38bd9f39233a4031fcf3ff8fc94ce86241fce24e',
    repo: 'OTTFFYZY.github.io',
    owner: 'OTTFFYZY',
    admin: ['OTTFFYZY'],
    id: location.pathname, 
    distractionFreeMode: false 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>

    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>《C&#43;&#43; Primer》 拾遗 第 14 章 重载运算与类型转换</b><nav id="TableOfContents">
  <ul>
    <li><a href="#第-14-章-重载运算与类型转换">第 14 章 重载运算与类型转换</a>
      <ul>
        <li><a href="#141-基本概念">14.1 基本概念</a>
          <ul>
            <li></li>
          </ul>
        </li>
        <li><a href="#142-输入和输出运算符">14.2 输入和输出运算符</a>
          <ul>
            <li></li>
          </ul>
        </li>
        <li><a href="#143-算术和关系运算符">14.3 算术和关系运算符</a>
          <ul>
            <li><a href="#1431-相等运算符">14.3.1 相等运算符</a></li>
            <li><a href="#1432-关系运算符">14.3.2 关系运算符</a></li>
          </ul>
        </li>
        <li><a href="#145-下标运算符">14.5 下标运算符</a></li>
        <li><a href="#146-递增和递减运算符">14.6 递增和递减运算符</a></li>
        <li><a href="#147-成员访问运算符">14.7 成员访问运算符</a></li>
        <li><a href="#148-函数调用运算符">14.8 函数调用运算符</a>
          <ul>
            <li></li>
            <li><a href="#1481-lambda-是函数对象">14.8.1 lambda 是函数对象</a></li>
            <li><a href="#1482-标准库定义的函数对象">14.8.2 标准库定义的函数对象</a></li>
            <li><a href="#1483-可调用对象与-function">14.8.3 可调用对象与 function</a></li>
          </ul>
        </li>
        <li><a href="#149-重载类型转换与运算符">14.9 重载、类型转换与运算符</a>
          <ul>
            <li><a href="#1491-类型转换运算符">14.9.1 类型转换运算符</a></li>
            <li><a href="#1492-避免有二义性的类型转换">14.9.2 避免有二义性的类型转换</a></li>
            <li><a href="#1493-函数匹配与重载运算符">14.9.3 函数匹配与重载运算符</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    

    Powered by the
    <a href="https://github.com/qqhann/hugo-primer" class="link-gray-dark">Hugo-Primer</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$','$']],
          displayMath: [['$$','$$']],
          processEscapes: true,
          processEnvironments: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
          TeX: { equationNumbers: { autoNumber: "AMS" },
               extensions: ["AMSmath.js", "AMSsymbols.js"] }
        }
      });
      </script>
      
      
    
    <script src="/assets/highlight.pack.js"></script>
    
    <script>
      hljs.initHighlightingOnLoad();
      
      hljs.configure({tabReplace: '    '});
    </script>

    <script src="/assets/copy-to-clipboard.js"></script>
  </body>
</html>
