<!DOCTYPE html>
<html>
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  《C&#43;&#43; Primer》 拾遗 第 6 章 函数 &ndash; OTTFF&#39;s Blog

    </title>
    
    
    <meta name="description" property="og:description" content="第 6 章 函数 6.1 函数基础 我们可以通过调用运算符 call operator 来执行函数。 形参 parameter 实参 argument 主调函数 calling function 被调函数 called function 空形参列表可以是空的括号，或是 void void f1() {} void f2(void) {} 6.1.1 局部对象 C&#43;&#43; 中名字有作用域，对象有声明周期 lifetime。 名|OTTFF&#39;s Blog">
    

    <meta name="apple-mobile-web-app-title" content="OTTFF&#39;s Blog">
    
    
    
    


    <link rel="stylesheet" href="/assets/syntax.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style.css">
    <link rel="stylesheet" href="/assets/github-gist.css">
    <link rel="stylesheet" href="/assets/copy-to-clipboard.css">
    
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">

      <div id="header" class="px-1 bg-white">
        <nav class="UnderlineNav UnderlineNav--right px-2">
  <a class="UnderlineNav-actions muted-link h2" href="https://ottffyzy.github.io/">
    OTTFF&#39;s Blog
  </a>

  
  
  <div class="UnderlineNav-body">
    
      
      
      <a class="UnderlineNav-item " href="/">
        
        <span>Home</span>
      </a>
      
    
      
      
      <a class="UnderlineNav-item " href="/templates">
        
        <span>Templates</span>
      </a>
      
    
      
      
      <a class="UnderlineNav-item " href="/categories/contests">
        
        <span>Contests</span>
      </a>
      
    
      
      
      <a class="UnderlineNav-item " href="/sols">
        
        <span>Solutions</span>
      </a>
      
    
      
      
      <a class="UnderlineNav-item " href="/categories/notes">
        
        <span>Notes</span>
      </a>
      
    
  </div>
  
</nav>

      </div>

      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">《C&#43;&#43; Primer》 拾遗 第 6 章 函数</div>
  </div>
  <div class="Subhead-description">
    

<a href='/categories/notes' class="muted-link">
  <span class="Label Label--gray-darker">Notes</span>
</a>









<a href='/series/cpp-primer' class="muted-link">
  <span class="Label Label--gray">Cpp Primer</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2021-05-28. Published at: 2021-05-28.">
        
          Published: 2021-05-28 周五 11:50:51
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom markdown">
      <h2 id="第-6-章-函数">第 6 章 函数</h2>
<h3 id="61-函数基础">6.1 函数基础</h3>
<p>我们可以通过调用运算符 <code>call operator</code> 来执行函数。</p>
<p>形参 <code>parameter</code></p>
<p>实参 <code>argument</code></p>
<p>主调函数 <code>calling function</code></p>
<p>被调函数 <code>called function</code></p>
<p>空形参列表可以是空的括号，或是 void</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div><h4 id="611-局部对象">6.1.1 局部对象</h4>
<p>C++ 中名字有作用域，对象有声明周期 <code>lifetime</code>。</p>
<p>名字的作用域是程序文本的一部分，名字在其中可见。</p>
<p>对象生命周期是程序执行过程中该对象存在的一段时间。</p>
<p>形参和函数体内部定义的变量是局部变量 <code>local variable</code>，它们仅在函数作用域中可见，同时会隐藏 <code>hide</code> 在外层作用域中的同名的其他声明。</p>
<h5 id="自动对象">自动对象</h5>
<p>只存在于块执行期间的对象称为自动对象 <code>automatic object</code>。</p>
<p>形参也是自动对象。</p>
<h5 id="局部静态对象">局部静态对象</h5>
<p><code>local static object</code> 有些对象的生命周期需要贯穿函数调用及之后的时间。</p>
<p>局部静态变量如果没有显示的初始值，则它会被默认初始化。</p>
<h4 id="612-函数声明">6.1.2 函数声明</h4>
<p>函数声明也称作函数原型 <code>function prototype</code>。</p>
<p>函数声明不需要函数体用分号代替。函数声明可以没有形参名字。</p>
<h3 id="62-参数传递">6.2 参数传递</h3>
<p>形参是引用类型时，实参被引用传递 <code>passed by reference</code> 或函数被传引用调用 <code>called by reference</code>。</p>
<p>实参值被拷贝给形参时，实参被值传递 <code>passed by value</code> 或者函数被传值调用 <code>called by value</code>。</p>
<h4 id="623-const-形参和实参">6.2.3 const 形参和实参</h4>
<p>注意实参初始化形参时会忽略掉顶层 const，因此这时需要注意下列重载是不行的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
</code></pre></div><h4 id="624-数组形参">6.2.4 数组形参</h4>
<p>注意因为数组不能拷贝，因此我们不能以值传递的方式使用数组参数，因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p>
<p>尽管不能以值传递的方式传递数组，但我们可以把参数形式写成类似数组的形式，下面三个形式是等价的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">[]);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span> <span class="c1">// 注意这个 10 只是期望大小，实际并不一定
</span></code></pre></div><p>当我期待更改数组内容时使用下面的形式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>
</code></pre></div><h5 id="数组引用形参">数组引用形参</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]);</span>
</code></pre></div><p>但注意，这种写法数组的维度是被限制死的。</p>
<h5 id="传递多维数组">传递多维数组</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">matrix</span><span class="p">)[</span><span class="mi">10</span><span class="p">],</span> <span class="kt">int</span> <span class="n">row</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">matrix</span><span class="p">[][</span><span class="mi">10</span><span class="p">],</span> <span class="kt">int</span> <span class="n">row</span><span class="p">);</span>
</code></pre></div><h4 id="625-main处理命令行选项">6.2.5 main：处理命令行选项</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{}</span>
</code></pre></div><p>其中 argc 是程序接受到的参数个数</p>
<p><code>argv[0]</code> 是程序名字或空字符串。</p>
<h4 id="626-含有可变形参的函数">6.2.6 含有可变形参的函数</h4>
<p>对于不定数量的参数，参数类型相同可以使用 initializer_list ，否则可以使用变长参数模板。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lst</span><span class="p">;</span>
<span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lst</span><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">};</span>
<span class="n">lst2</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="n">lst2</span> <span class="o">=</span> <span class="n">lst</span>
<span class="n">lst</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="n">lst</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="n">lst</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</code></pre></div><p>注意 initializer_list 中的元素是常量值。</p>
<h5 id="省略符形参">省略符形参</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">parm_list</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(...);</span>
</code></pre></div><p>这是为了 C++ 代码便于访问 C 代码设置的，这些代码使用了 varargs 的 C 标准库的功能。</p>
<h3 id="63-返回类型和-return-语句">6.3 返回类型和 return 语句</h3>
<h4 id="631-无返回值的函数">6.3.1 无返回值的函数</h4>
<p>返回类型的是 void 的函数也可以使用带有表达式的 return 的语句，这时表达式必须是另一个返回 void 的函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="nf">f2</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">f1</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">f2</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h4 id="632-有返回值函数">6.3.2 有返回值函数</h4>
<h5 id="值是如何被返回的">值是如何被返回的</h5>
<p>返回一个值的方式和初始化变量或形参的方式一致，返回值用来初始化调用点的一个临时量，这个临时量就是函数调用的结果。</p>
<p>如果函数返回值是引用，则它只是所引用对象的别名。</p>
<p>不要返回局部对象的引用或指针！</p>
<h5 id="引用返回左值">引用返回左值</h5>
<p>如果返回类型时非常量引用，则我们可以对其进行赋值。</p>
<h5 id="列表初始化返回值">列表初始化返回值</h5>
<p>可以使用列表初始化初始化返回值，与其他情况使用列表初始化相同。</p>
<h5 id="主函数-main-的返回值">主函数 main 的返回值</h5>
<p>为了使返回值与机器无关 cstdlib 中定义了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">EXIT_FAILURE</span><span class="p">;</span>
<span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</code></pre></div><h4 id="633-返回数组指针">6.3.3 返回数组指针</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">arrT</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="c1">// 或
</span><span class="c1"></span><span class="k">using</span> <span class="n">arrT</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">arrT</span><span class="o">*</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
</code></pre></div><p>上述写法会好写一点</p>
<p>也可以用下面的写法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">))[</span><span class="mi">10</span><span class="p">];</span>
</code></pre></div><h5 id="使用尾置返回类型">使用尾置返回类型</h5>
<p>尾置返回类型 <code>trailing return type</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">auto</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">10</span><span class="p">];</span>
</code></pre></div><h5 id="使用-decltype">使用 decltype</h5>
<p>当我们知道函数返回的指针指向哪个数组时可以使用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">odd</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">even</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">odd</span><span class="p">)</span> <span class="o">*</span><span class="n">arrPtr</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="nl">odd</span> <span class="p">:</span> <span class="o">&amp;</span><span class="n">even</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="64-函数重载">6.4 函数重载</h3>
<p>同一作用域内几个函数名字相同但形参列表不同，我们称之为重载 <code>overloaded</code> 函数。</p>
<p>main 函数不能重载。</p>
<p>注意有时候形参看起来不一样，但实际是相同的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="n">A</span> <span class="n">B</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">B</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div><p>注意不能重载参数只有顶层 const 的不同的函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="n">a</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">P</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">P</span><span class="o">*</span> <span class="k">const</span><span class="p">);</span>
</code></pre></div><p>如下是正确的重载</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">*</span><span class="p">);</span>
</code></pre></div><p>编译器将通过实参是否是常量来判断调用哪个函数。</p>
<p>const_cast 和重载</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">shorterString</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="nl">s1</span> <span class="p">:</span> <span class="n">s2</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">string</span> <span class="o">&amp;</span><span class="n">shorterString</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">shorterString</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">s2</span><span class="p">));</span>
    <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h5 id="调用重载函数">调用重载函数</h5>
<p>函数匹配 <code>function matching</code> 也称为冲在确定 <code>overload resolution</code> 是将函数调用与一组重载函数中的某个关联起来的过程。</p>
<p>调用时存在三种可能：</p>
<p>找到最佳匹配 <code>best match</code>。</p>
<p>找不到匹配，发出无匹配<code>no match</code> 错误信息。</p>
<p>有多于一个匹配，并且没有明显的最佳匹配。此时返回错误信息二义性调用 <code>ambiguous call</code>。</p>
<h4 id="641-重载与作用域">6.4.1 重载与作用域</h4>
<p>一般来说不会将函数声明置于局部作用域内。</p>
<p>注意内层声明会屏蔽外层所有同名的声明，不存在内层函数对外层重载。</p>
<p>C++ 中名字查找在类型检查之前。</p>
<h3 id="65-特殊用途语言特性">6.5 特殊用途语言特性</h3>
<h4 id="651-默认实参">6.5.1 默认实参</h4>
<p><code>default argument</code></p>
<h5 id="默认实参声明">默认实参声明</h5>
<p>注意多次声明同一函数是合法的，但在某给定作用域中，形参只能被赋予一次默认实参。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">,</span><span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="mi">10</span><span class="p">);</span>
<span class="c1">// void f(int a,int b,int c=100); // 错误
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// 正确
</span></code></pre></div><p>注意局部变量不能作为默认实参，表达式能转换成形参类型则也可以作为默认实参。</p>
<h4 id="652-内联函数和-constexpr-函数">6.5.2 内联函数和 constexpr 函数</h4>
<h5 id="constexpr-函数">constexpr 函数</h5>
<p>是能用于常量表达式的函数，函数的返回类型和所有形参必须是字面值类型，函数体中必须有且只有一条 return 语句。</p>
<p>constexpr 会在编译时隐式指定为内联函数。</p>
<p>constexpr 函数不一定返回常量表达式。</p>
<p>当 constexpr 函数的参数不是常量时，则它不是一个常量表达式。</p>
<p>内联函数和 constexpr 函数，可以在程序中多次定义，因为只有声明是无法内联展开的，但这些定义应当完全一致，所以通常把内联函数和 constexpr 函数放在头文件。</p>
<h4 id="653-调试帮助">6.5.3 调试帮助</h4>
<p>assert 是一个定义在 cassert 中的预处理宏。</p>
<p>当定义了 <code>NDEBUG</code> 预处理变量时，cassert 什么都不会做，否则会检查表达式是否为真，如果为假则输出信息并终止程序执行。</p>
<p>可以使用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">__func__</span> <span class="c1">// 输出当前函数名字
</span><span class="c1"></span><span class="n">__FILE__</span> <span class="c1">// 当前文件名
</span><span class="c1"></span><span class="n">__LINE__</span> <span class="c1">// 当前行号
</span><span class="c1"></span><span class="n">__TIME__</span> <span class="c1">// 文件编译时间
</span><span class="c1"></span><span class="n">__DATE__</span> <span class="c1">// 文件编译日期
</span></code></pre></div><h3 id="66-函数匹配">6.6 函数匹配</h3>
<p>函数匹配的第一步是确定候选函数 <code>candidate function</code>，候选函数满足与被调函数同名，声明在调用点可见。</p>
<p>第二步考察实参，从候选函数中选出可行函数 <code>viable function</code>，可行函数满足形参数量与实参数量相等，实参类型与形参类型相同，或能转换成形参的类型。</p>
<p>第三步是寻找最佳匹配，当有一个函数满足，每个实参匹配都不劣于其他可行函数的匹配，有至少一个实参匹配优于其他可行函数的匹配，则它是最优匹配。</p>
<p>实参到形参类型转化的级别：</p>
<ol>
<li>精确匹配：实参和形参类型相同，实参从数组类型或函数类型转换成对应的指针类型，向实参添加顶层 const 或删除顶层 const</li>
<li>通过 const 转换实现的匹配</li>
<li>通过类型提升实现的匹配</li>
<li>通过算术类型转换或指针转换实现的匹配</li>
<li>通过类类型转换实现的匹配</li>
</ol>
<h3 id="67-函数指针">6.7 函数指针</h3>
<p>函数指针指向某种特定类型。</p>
<p>函数类型由返回值和形参类型共同决定。</p>
<p>不同类型的函数指针之间不能转换。</p>
<p>可以将 nullptr 或 0 赋值给函数指针。</p>
<p>以下形式赋值函数指针是相同的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">f</span><span class="p">();</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)()</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)()</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">;</span>
</code></pre></div><p>使用函数指针和使用函数名是类似的。</p>
<h5 id="函数指针形参">函数指针形参</h5>
<p>和数组类似，虽然不能定义函数类型的形参，但是可以定义指向函数的指针。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">,</span><span class="kt">bool</span> <span class="n">pf</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span><span class="kt">int</span> <span class="n">d</span><span class="p">));</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">,</span><span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span><span class="kt">int</span> <span class="n">d</span><span class="p">));</span>
</code></pre></div><p>也可以使用 decltype 得到函数类型，但是这时需要注意 decltype 得到的函数类型不会自动转换成指针类型。不过使用上看起来好像没什么问题，如下 4 种写法都是可以通过编译并运行的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">fvoid</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;do something</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)()</span> <span class="o">=</span> <span class="n">fvoid</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="nf">Func</span><span class="p">();</span>
<span class="k">typedef</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">fvoid</span><span class="p">)</span> <span class="n">Func2</span><span class="p">;</span>
<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">FuncP</span><span class="p">)();</span>
<span class="k">typedef</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">fvoid</span><span class="p">)</span> <span class="o">*</span><span class="n">FuncP2</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="n">Func</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">();</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="n">Func2</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">();</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">f3</span><span class="p">(</span><span class="n">FuncP</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">();</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">f4</span><span class="p">(</span><span class="n">FuncP2</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">();</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">f1</span><span class="p">(</span><span class="n">fvoid</span><span class="p">);</span>
  <span class="n">f2</span><span class="p">(</span><span class="n">fvoid</span><span class="p">);</span>
  <span class="n">f3</span><span class="p">(</span><span class="n">fvoid</span><span class="p">);</span>
  <span class="n">f4</span><span class="p">(</span><span class="n">fvoid</span><span class="p">);</span>

  <span class="n">f1</span><span class="p">(</span><span class="n">pf</span><span class="p">);</span>
  <span class="n">f2</span><span class="p">(</span><span class="n">pf</span><span class="p">);</span>
  <span class="n">f3</span><span class="p">(</span><span class="n">pf</span><span class="p">);</span>
  <span class="n">f4</span><span class="p">(</span><span class="n">pf</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h5 id="返回指向函数的指针">返回指向函数的指针</h5>
<p>这里最好还是使用类型别名或者尾置返回类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="n">F</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">using</span> <span class="n">PF</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(){}</span>

<span class="n">PF</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// F f2() { return f; } // compile error 不能返回函数类型
</span><span class="c1"></span><span class="n">F</span> <span class="o">*</span><span class="nf">f3</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
  </section>

  <section>
    
        <a href="/notes/cppprimer/c5/" class="previous_page">Prev: 《C&#43;&#43; Primer》 拾遗 第 5 章 语句 </a>
    
     <br> 
    
        <a href="/notes/cppprimer/c7/" class="next_page">Next: 《C&#43;&#43; Primer》 拾遗 第 7 章 类 </a>
    
  </section>

  <section>
    
      
      
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'b60070c8fc2c3e5b67f2',
    clientSecret: '38bd9f39233a4031fcf3ff8fc94ce86241fce24e',
    repo: 'OTTFFYZY.github.io',
    owner: 'OTTFFYZY',
    admin: ['OTTFFYZY'],
    id: location.pathname, 
    distractionFreeMode: false 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>

    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>《C&#43;&#43; Primer》 拾遗 第 6 章 函数</b><nav id="TableOfContents">
  <ul>
    <li><a href="#第-6-章-函数">第 6 章 函数</a>
      <ul>
        <li><a href="#61-函数基础">6.1 函数基础</a></li>
        <li><a href="#62-参数传递">6.2 参数传递</a></li>
        <li><a href="#63-返回类型和-return-语句">6.3 返回类型和 return 语句</a></li>
        <li><a href="#64-函数重载">6.4 函数重载</a></li>
        <li><a href="#65-特殊用途语言特性">6.5 特殊用途语言特性</a></li>
        <li><a href="#66-函数匹配">6.6 函数匹配</a></li>
        <li><a href="#67-函数指针">6.7 函数指针</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    

    Powered by the
    <a href="https://github.com/qqhann/hugo-primer" class="link-gray-dark">Hugo-Primer</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$','$']],
          displayMath: [['$$','$$']],
          processEscapes: true,
          processEnvironments: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
          TeX: { equationNumbers: { autoNumber: "AMS" },
               extensions: ["AMSmath.js", "AMSsymbols.js"] }
        }
      });
      </script>
      
      
    
    <script src="/assets/highlight.pack.js"></script>
    
    <script>
      hljs.initHighlightingOnLoad();
      
      hljs.configure({tabReplace: '    '});
    </script>

    <script src="/assets/copy-to-clipboard.js"></script>
  </body>
</html>
